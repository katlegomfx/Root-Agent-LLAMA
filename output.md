
## the following is the working example:
### src/app/layout.tsx

```ts
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

```

### src/app/page.tsx

```ts
// pages/index.tsx
"use client"
import { useState } from 'react';

export default function Home() {
  const [userInput, setUserInput] = useState('');
  const [conversation, setConversation] = useState<Array<{ role: string, content: string }>>([]);

  const handleChatSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!userInput.trim()) return;

    // Append the user message to the conversation for chat
    setConversation(prev => [...prev, { role: 'user', content: userInput }]);

    try {
      const res = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userInput })
      });
      const data = await res.json();
      setConversation(prev => [...prev, { role: 'assistant', content: data.response }]);
      setUserInput('');
    } catch (err) {
      console.error(err);
    }
  };

  const handleGenerate = async () => {
    if (!userInput.trim()) return;

    // Append the user message to the conversation for generate
    setConversation(prev => [...prev, { role: 'user', content: userInput }]);

    try {
      const res = await fetch('/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userInput })
      });
      const data = await res.json();
      setConversation(prev => [...prev, { role: 'assistant', content: data.response }]);
      setUserInput('');
    } catch (err) {
      console.error(err);
    }
  };

  return (
    <div style={{ margin: '2rem' }}>
      <h1>Chat with Ollama</h1>
      <div style={{ marginBottom: '1rem', border: '1px solid #ccc', padding: '1rem', minHeight: '300px' }}>
        {conversation.map((msg, idx) => (
          <p key={idx}><strong>{msg.role}:</strong> {msg.content}</p>
        ))}
      </div>
      <form onSubmit={handleChatSubmit}>
        <input
          type="text"
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          placeholder="Type your message"
          style={{ width: '80%', marginRight: '1rem' }}
        />
        <button type="submit">Chat</button>
        <button type="button" onClick={handleGenerate} style={{ marginLeft: '0.5rem' }}>
          Generate
        </button>
      </form>
    </div>
  );
}

```

### src/pages/api/chat.ts

```ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { Ollama } from 'ollama';

const ollama = new Ollama();

// In-memory conversation history (demo purposes)
const messages: Array<{ role: string, content: string }> = [];

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', ['POST']);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }
  
  const { userInput } = req.body;
  if (!userInput) {
    return res.status(400).json({ error: 'Missing userInput' });
  }

  console.log("Ollama Chat: Received userInput:", userInput);
  
  let responseContent = "";
  
  try {
    const chatMessages = [
      ...messages,
      { role: "system", content: "You are a helpful assistant. You only give a short sentence by answer." },
      { role: "user", content: userInput }
    ];
    console.log("Ollama Chat: Calling ollama.chat with parameters:", {
      model: "llama3.2",
      messages: chatMessages,
      stream: true,
    });
    
    // Call Ollama with streaming enabled
    const stream = await ollama.chat({
      model: "llama3.2",
      messages: chatMessages,
      stream: true,
    });
    
    for await (const chunk of stream) {
      if (chunk.message) {
        responseContent += chunk.message.content;
      }
    }
    
    console.log("Ollama Chat: Received responseContent:", responseContent);
    
    // Update conversation history
    messages.push(
      { role: "user", content: userInput },
      { role: "assistant", content: responseContent }
    );
    
    res.status(200).json({ response: responseContent });
  } catch (error) {
    console.error("Ollama Chat: Error calling ollama.chat:", error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}

```

### src/pages/api/generate.ts

```ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { Ollama } from 'ollama';

const ollama = new Ollama();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', ['POST']);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  const { userInput } = req.body;
  if (!userInput) {
    return res.status(400).json({ error: 'Missing userInput' });
  }

  let responseContent = "";

  try {
    console.log("Ollama Generate: Received prompt:", userInput);
    console.log("Ollama Generate: Calling ollama.generate with parameters:", {
      model: "llama3.2",
      prompt: userInput,
      stream: true,
    });

    // Call Ollama's generate method with streaming enabled
    const stream = await ollama.generate({
      model: "llama3.2",
      prompt: userInput,
      stream: true
    });

    for await (const chunk of stream) {
      if (chunk.response) {
        responseContent += chunk.response;
      }
    }

    console.log("Ollama Generate: Received responseContent:", responseContent);
    res.status(200).json({ response: responseContent });
  } catch (error) {
    console.error("Ollama Generate: Error calling ollama.generate:", error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}

```



## work on the following:
### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/layout.tsx

```ts
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { Toaster } from "react-hot-toast";
import "./globals.css";
import { ThemeProvider } from "@/components/theme-provider";
import { ROOT_URL } from "@/utils/config";
import { ModeToggle } from "@/components/mode-toggle";
import { GoogleAnalytics } from "@next/third-parties/google";
import { MAINTENANCE_MODE } from "@/lib/settings";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
	title: "Groq Appgen",
	description: "Interactive HTML editor with AI generation",

	icons: {
		icon: "/icons/icon.png",
	},

	openGraph: {
		type: "website",
		url: ROOT_URL,
		title: "Groq Appgen",
		description: "Interactive HTML editor with AI generation",
		images: `${ROOT_URL}/og-labs.png`,
	},
};

export default function RootLayout({
	children,
}: {
	children: React.ReactNode;
}) {
	return (
		<html lang="en">
			<body className={inter.className}>
				<ThemeProvider attribute="class" defaultTheme="system" enableSystem>
					{MAINTENANCE_MODE ? (
						<div className="text-center text-gray-500 py-8">
							{"We're currently undergoing maintenance. We'll be back soon!"}
						</div>
					) : (
						<>
							{children}
							<ModeToggle />
							<Toaster position="bottom-right" />
						</>
					)}
				</ThemeProvider>
				<GoogleAnalytics gaId="G-MGQ7E93R12" />
			</body>
		</html>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/page.tsx

```ts
"use client";

import { StudioProvider } from "@/providers/studio-provider";
import MainView from "./components/main-view";

export default function Home() {
	return (
		<StudioProvider>
			<MainView />
		</StudioProvider>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/AppLogo.tsx

```ts
import { cn } from "@/lib/utils";
import { useTheme } from "next-themes";
import Image from "next/image";
import React from "react";

export default function AppLogo({ className, size = 80 }: { className?: string; size?: number }) {
	const { resolvedTheme, theme } = useTheme();
	const [mounted, setMounted] = React.useState(false);

	React.useEffect(() => {
		setMounted(true);
	}, []);

	// Avoid hydration mismatch by using a default theme before mounting
	const logoSrc = !mounted ? "/groqlabs_logo-black.png" : 
		(resolvedTheme === "dark" ? "/groqlabs_logo-white.png" : "/groqlabs_logo-black.png");

	return (
		<div className={cn("flex flex-col items-center gap-2", className)}>
			<Image 
				src={logoSrc} 
				alt="Groq" 
				width={size} 
				height={size}
				style={{ width: 'auto', height: size/3.41333333333 }}
			/>
		</div>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/CopyButton.tsx

```ts
import { useState } from "react";
import { IoCopyOutline } from "react-icons/io5";
import { Tooltip } from "react-tooltip";
import { Button } from "./ui/button";

interface CopyButtonProps {
	code: string;
}

export function CopyButton({ code }: CopyButtonProps) {
	const [copied, setCopied] = useState(false);

	const handleCopy = async () => {
		await navigator.clipboard.writeText(code);
		setCopied(true);
		setTimeout(() => setCopied(false), 2000);
	};

	return (
		<>
			<Button
				onClick={handleCopy}
				variant="outline"
				size="icon"
				data-tooltip-id="copy-tooltip"
				data-tooltip-content={copied ? "Copied!" : "Copy code"}
			>
				<IoCopyOutline size={20} />
			</Button>
			<Tooltip
				id="copy-tooltip"
				place="left"
				className="!bg-gray-800 !px-2 !py-1 !text-sm !z-50"
			/>
		</>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/DrawingCanvas.tsx

```ts
import { useRef, useState, useEffect } from 'react';
import { Button } from './ui/button';

interface DrawingCanvasProps {
  onDrawingComplete: (imageData: string) => void;
  onClose: () => void;
}

export function DrawingCanvas({ onDrawingComplete, onClose }: DrawingCanvasProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    setContext(ctx);

    // Set white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }, []);

  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    if (!context) return;
    setIsDrawing(true);
    
    let x: number, y: number;
    if ('touches' in e) {
      const rect = canvasRef.current?.getBoundingClientRect();
      if (!rect) return;
      const canvas = canvasRef.current;
      if (!canvas) return;
      // For touch events, calculate the scale and apply it
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      x = (e.touches[0].clientX - rect.left) * scaleX;
      y = (e.touches[0].clientY - rect.top) * scaleY;
    } else {
      // For mouse events, use the offsetX/Y directly
      const canvas = canvasRef.current;
      if (!canvas) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      x = e.nativeEvent.offsetX * scaleX;
      y = e.nativeEvent.offsetY * scaleX;
    }
    
    context.beginPath();
    context.moveTo(x, y);
  };

  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !context) return;
    e.preventDefault(); // Prevent scrolling on mobile

    let x: number, y: number;
    if ('touches' in e) {
      const rect = canvasRef.current?.getBoundingClientRect();
      if (!rect) return;
      const canvas = canvasRef.current;
      if (!canvas) return;
      // For touch events, calculate the scale and apply it
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      x = (e.touches[0].clientX - rect.left) * scaleX;
      y = (e.touches[0].clientY - rect.top) * scaleY;
    } else {
      // For mouse events, use the offsetX/Y directly
      const canvas = canvasRef.current;
      if (!canvas) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      x = e.nativeEvent.offsetX * scaleX;
      y = e.nativeEvent.offsetY * scaleX;
    }

    context.lineTo(x, y);
    context.stroke();
  };

  const stopDrawing = () => {
    if (!context) return;
    setIsDrawing(false);
    context.closePath();
  };

  const handleComplete = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const imageData = canvas.toDataURL('image/jpeg');
    onDrawingComplete(imageData);
  };

  const handleClear = () => {
    if (!context || !canvasRef.current) return;
    context.fillStyle = '#ffffff';
    context.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 touch-none">
      <div className="bg-background p-4 rounded-lg w-full max-w-[400px]">
        <div className="flex flex-col gap-4">
          <canvas
            ref={canvasRef}
            width={300}
            height={500}
            className="border border-border rounded-lg cursor-crosshair bg-white w-full touch-none"
            onMouseDown={startDrawing}
            onMouseMove={draw}
            onMouseUp={stopDrawing}
            onMouseLeave={stopDrawing}
            onTouchStart={startDrawing}
            onTouchMove={draw}
            onTouchEnd={stopDrawing}
          />
          <div className="flex justify-between gap-2">
            <Button variant="outline" onClick={handleClear} className="min-w-[60px]">
              Clear
            </Button>
            <div className="flex gap-2">
              <Button variant="outline" onClick={onClose} className="min-w-[60px]">
                Cancel
              </Button>
              <Button onClick={handleComplete} className="min-w-[60px]">
                Done
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/groq-logo.tsx

```ts
export default function GroqLogo() {
	return (
		<svg
			aria-label="Groq"
			role="img"
			width="100"
			height="30"
			viewBox="0 0 834 305"
			fill="none"
		>
			<path
				d="M499.3 0.5C441.7 0.5 394.9 47.2 394.9 104.9C394.9 162.6 441.6 209.3 499.3 209.3C557 209.3 603.7 162.6 603.7 104.9C603.6 47.3 556.9 0.6 499.3 0.5ZM499.3 170.1C463.3 170.1 434.1 140.9 434.1 104.9C434.1 68.9 463.3 39.7 499.3 39.7C535.3 39.7 564.5 68.9 564.5 104.9C564.5 140.9 535.3 170.1 499.3 170.1Z"
				className="fill-foreground"
			/>
			<path
				d="M355.2 0.900018C351.6 0.500018 348.1 0.300018 344.5 0.300018C342.7 0.300018 341 0.300018 339.3 0.400018C337.6 0.500018 335.8 0.600018 334.1 0.700018C327.1 1.20002 320.1 2.40002 313.3 4.30002C299.4 8.00002 286.3 14.6 275 23.5C263.4 32.7 254.2 44.5 247.9 57.9C244.8 64.6 242.5 71.7 241 78.9C240.3 82.5 239.8 86.1 239.4 89.7C239.3 91.5 239.1 93.3 239.1 95.1L239 97.8V100.3L239.1 135.3L239.2 170.2L239.4 205.1H278.5L278.7 170.2L278.8 135.3L278.9 100.3V98.3V96.6C278.9 95.5 279.1 94.4 279.1 93.3C279.3 91.1 279.7 89 280.1 86.8C281 82.6 282.3 78.5 284.1 74.6C287.7 66.8 293.1 60 299.8 54.6C306.8 49 314.9 44.9 323.5 42.6C327.9 41.4 332.5 40.6 337.1 40.2C338.3 40.1 339.4 40 340.6 40C341.8 40 343 39.9 344.1 39.9C346.3 39.9 348.6 40 350.8 40.2C359.7 41.1 368.3 43.8 376.2 48.2L395.7 14.3C383.3 7.10002 369.5 2.50002 355.2 0.900018Z"
				className="fill-foreground"
			/>
			<path
				d="M105.3 1.4035e-05C47.7 -0.499986 0.500014 45.8 1.4035e-05 103.4C-0.499986 161 45.8 208.2 103.4 208.7H139.6V169.6H105.3C69.3 170 39.7 141.2 39.3 105.1C38.9 69 67.7 39.5 103.8 39.1C104.3 39.1 104.8 39.1 105.3 39.1C141.3 39.1 170.5 68.3 170.7 104.3V200.4C170.7 236.1 141.6 265.2 106 265.6C88.9 265.5 72.6 258.6 60.6 246.5L32.9 274.2C52.1 293.5 78.1 304.5 105.3 304.7H106.7C163.6 303.9 209.3 257.7 209.6 200.8V101.7C208.2 45.2 161.9 0.100014 105.3 1.4035e-05Z"
				className="fill-foreground"
			/>
			<path
				d="M729.7 0.5C672.1 0.5 625.3 47.2 625.4 104.9C625.4 162.5 672.1 209.2 729.7 209.2H765.4V170.1H729.7C693.7 170.1 664.5 140.9 664.5 104.9C664.5 68.9 693.7 39.7 729.7 39.7C763.5 39.7 791.7 65.6 794.7 99.3H794.6V299.7H833.7V104.9C833.7 47.3 787.2 0.5 729.7 0.5Z"
				className="fill-foreground"
			/>
		</svg>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/MicrophoneButton.tsx

```ts
import { useState, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Mic } from "lucide-react";

interface MicrophoneButtonProps {
	onTranscription: (text: string) => void;
	disabled?: boolean;
}

export function MicrophoneButton({
	onTranscription,
	disabled,
}: MicrophoneButtonProps) {
	const [isRecording, setIsRecording] = useState(false);
	const mediaRecorder = useRef(null);
	const audioChunks = useRef([]);

	const startRecording = async () => {
		try {
			const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
			mediaRecorder.current = new MediaRecorder(stream);
			audioChunks.current = [];

			mediaRecorder.current.ondataavailable = (event) => {
				audioChunks.current.push(event.data);
			};

			mediaRecorder.current.onstop = async () => {
				const audioBlob = new Blob(audioChunks.current, { type: "audio/webm" });
				const formData = new FormData();
				formData.append("audio", audioBlob);

				try {
					const response = await fetch("/api/transcribe", {
						method: "POST",
						body: formData,
					});

					const data = await response.json();
					if (response.ok) {
						onTranscription(data.transcription);
					} else {
						console.error("Transcription failed:", data.error);
					}
				} catch (error) {
					console.error("Error sending audio:", error);
				}

				// Clean up the media stream
				for (const track of stream.getTracks()) {
					track.stop();
				}
			};

			mediaRecorder.current.start();
			setIsRecording(true);
		} catch (error) {
			console.error("Error accessing microphone:", error);
		}
	};

	const stopRecording = () => {
		if (mediaRecorder.current && mediaRecorder.current.state !== "inactive") {
			mediaRecorder.current.stop();
			setIsRecording(false);
		}
	};

	const toggleRecording = () => {
		if (isRecording) {
			stopRecording();
		} else {
			startRecording();
		}
	};

	return (
		<div className="relative">
			<Button
				disabled={disabled}
				type="button"
				variant="ghost"
				size="icon"
				className={`rounded-full relative z-10 ${
					isRecording ? "text-orange-500 hover:text-orange-600" : ""
				}`}
				onClick={toggleRecording}
			>
				<Mic className="h-5 w-5" />
			</Button>
			{isRecording && (
				<div className="absolute inset-0 z-0">
					<div className="absolute inset-0 animate-ping rounded-full bg-orange-400 opacity-75" />
					<div className="absolute inset-[-4px] animate-pulse rounded-full bg-orange-300 opacity-50" />
					<div className="absolute inset-[-8px] animate-pulse delay-75 rounded-full bg-orange-200 opacity-25" />
				</div>
			)}
		</div>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/mode-toggle.tsx

```ts
"use client";

import * as React from "react";
import { Moon, MoonIcon, Sun } from "lucide-react";
import { useTheme } from "next-themes";

import { Button } from "@/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

export function ModeToggle() {
	const { setTheme } = useTheme();

	return (
		<DropdownMenu>
			<DropdownMenuTrigger asChild>
				<Button variant="outline" size="icon" className="fixed bottom-3 left-4">
					<Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
					<Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
					<span className="sr-only">Toggle theme</span>
				</Button>
			</DropdownMenuTrigger>
			<DropdownMenuContent align="end">
				<DropdownMenuItem onClick={() => setTheme("light")}>
					Light
				</DropdownMenuItem>
				<DropdownMenuItem onClick={() => setTheme("dark")}>
					Dark
				</DropdownMenuItem>
				<DropdownMenuItem onClick={() => setTheme("system")}>
					System
				</DropdownMenuItem>
			</DropdownMenuContent>
		</DropdownMenu>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/model-selector.tsx

```ts
import { ChevronDown, Check } from "lucide-react";
import { MODEL_OPTIONS } from "@/utils/models";
import { useState, useEffect, useRef } from "react";

interface ModelSelectorProps {
  options?: string[];
  onChange: (model: string) => void;
  initialModel?: string;
}

const ModelSelector = ({ 
  options = MODEL_OPTIONS, 
  onChange, 
  initialModel 
}: ModelSelectorProps) => {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedModel, setSelectedModel] = useState(() => {
    if (initialModel) return initialModel;
    if (typeof window !== "undefined") {
      return localStorage.getItem("selectedModel") || options[0];
    }
    return options[0];
  });
  const [dropdownPosition, setDropdownPosition] = useState("right");
  const dropdownRef = useRef(null);

  // Sync with localStorage on mount
  useEffect(() => {
    if (typeof window !== "undefined") {
      const storedModel = localStorage.getItem("selectedModel");
      if (storedModel) {
        setSelectedModel(storedModel);
        if (onChange) onChange(storedModel);
      }
    }
  }, [onChange]);

  // Update selectedModel when initialModel changes
  useEffect(() => {
    if (initialModel && initialModel !== selectedModel) {
      setSelectedModel(initialModel);
    }
  }, [initialModel, selectedModel]);

  const handleSelect = (model: string) => {
    setSelectedModel(model);
    if (typeof window !== "undefined") {
      localStorage.setItem("selectedModel", model);
    }
    if (onChange) onChange(model);
    setIsOpen(false);
  };

  // Calculate position before opening the dropdown
  const toggleDropdown = () => {
    if (!isOpen && dropdownRef.current) {
      const rect = dropdownRef.current.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      
      if (rect.right + 300 > viewportWidth) {
        setDropdownPosition("left");
      } else {
        setDropdownPosition("right");
      }
    }
    setIsOpen(!isOpen);
  };

  // Close dropdown on outside click
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  return (
    <div ref={dropdownRef} className="relative w-full md:w-auto">
      <div
        onClick={toggleDropdown}
        className="flex items-center justify-end gap-2 cursor-pointer bg-transparent hover:bg-accent hover:text-accent-foreground
rounded-lg p-2 transition-colors"
      >
        <span className="text-black dark:text-white text-right">{selectedModel}</span>
        <ChevronDown
          className={`w-5 h-5 transition-transform ${isOpen ? "rotate-180" : ""} text-black dark:text-white`}
        />
      </div>

      {isOpen && (
        <ul 
          className={`absolute z-50 mt-2 ${dropdownPosition === "left" ? "right-0" : "left-0"} w-full md:w-[300px] bg-white dark:bg-black border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg max-h-[50vh] overflow-y-auto`}
        >
          {options.map((option) => (
            <li
              key={option}
              onClick={() => handleSelect(option)}
              className={`flex items-center justify-between px-6 py-3 cursor-pointer hover:bg-accent hover:text-accent-foreground
 transition-colors gap-4 ${
                selectedModel === option ? "bg-transparent text-blue-600 dark:text-blue-400" : "text-black dark:text-white"
              }`}
            >
              <span>{option}</span>
              {selectedModel === option && <Check className="w-4 h-4 text-blue-600 dark:text-blue-400" />}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default ModelSelector;

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ReloadButton.tsx

```ts
import type { RefObject } from "react";
import { IoReloadOutline } from "react-icons/io5";
import { Tooltip } from "react-tooltip";
import { Button } from "./ui/button";

interface ReloadButtonProps {
	iframeRef: RefObject<HTMLIFrameElement>;
}

export function ReloadButton({ iframeRef }: ReloadButtonProps) {
	const handleReload = () => {
		if (iframeRef.current) {
			const currentSrcDoc = iframeRef.current.srcdoc;
			iframeRef.current.srcdoc = '';
			iframeRef.current.srcdoc = currentSrcDoc;
		}
	};

	return (
		<>
			<Button
				onClick={handleReload}
				variant="outline"
				size="icon"
				data-tooltip-id="reload-tooltip"
				data-tooltip-content="Reload preview"
			>
				<IoReloadOutline size={20} />
			</Button>
			<Tooltip
				id="reload-tooltip"
				place="left"
				className="!bg-gray-800 !px-2 !py-1 !text-sm !z-50"
			/>
		</>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/RemixButton.tsx

```ts
import { FiGitBranch } from "react-icons/fi";
import { Tooltip } from "react-tooltip";
import { Button } from "./ui/button";

interface RemixButtonProps {
	sessionId?: string;
	version?: string;
	disabled?: boolean;
}

export function RemixButton({
	sessionId,
	version,
	disabled,
}: RemixButtonProps) {
	const handleClick = () => {
		if (sessionId && version) {
			const sourceParam = `${sessionId}/${version}`;
			window.location.href = `/?source=${encodeURIComponent(sourceParam)}`;
		}
	};

	return (
		<>
			<Button
				onClick={handleClick}
				disabled={disabled}
				variant="outline"
				size="icon"
				data-tooltip-id="remix-tooltip"
				data-tooltip-content="Remix this app!"
			>
				<FiGitBranch className="w-5 h-5" />
			</Button>
			<Tooltip id="remix-tooltip" />
		</>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/share-button.tsx

```ts
import { useCallback, useEffect, useRef, useState } from "react";
import { IoShareOutline } from "react-icons/io5";
import { Button } from "./ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "./ui/popover";
import { Input } from "./ui/input";
import { Textarea } from "./ui/textarea";
import { useStudio } from "@/providers/studio-provider";
import { Check, Copy } from "lucide-react";
import { useCopyToClipboard } from "@/hooks/use-copy-to-clipboard";
import { cn } from "@/lib/utils";
import { toast } from "react-hot-toast";
import { Checkbox } from "./ui/checkbox";

interface ShareButtonProps {
	sessionId?: string;
	version?: string;
	disabled?: boolean;
	signature: string;
}

export function ShareButton({
	sessionId,
	version,
	signature,
	disabled,
}: ShareButtonProps) {
	const { currentHtml } = useStudio();
	const { isCopied, copyToClipboard } = useCopyToClipboard({});
	const [status, setStatus] = useState<"idle" | "sharing" | "shared">("idle");
	const [open, setOpen] = useState(false);
	const [url, setUrl] = useState("");
	const [avoidGallery, setAvoidGallery] = useState(false);

	const [title, setTitle] = useState("");
	const [description, setDescription] = useState("");
	const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);

	// Ref for the input that appears after sharing
	const sharedInputRef = useRef<HTMLInputElement>(null);

	const handleShare = async () => {
		setStatus("sharing");
		const version = crypto.randomUUID();
		const response = await fetch(`/api/apps/${sessionId}/${version}`, {
			method: "POST",
			body: JSON.stringify({
				html: currentHtml,
				signature,
				title,
				description,
				avoidGallery,
			}),
		});
		if (!response.ok) {
			toast.error("Failed to share app");
			setStatus("idle");
			return;
		}
		const url = `/apps/${sessionId}/${version}`;
		setUrl(`${window.location.origin}${url}`);
		setStatus("shared");
	};

	const fetchSuggestions = useCallback(async () => {
		setIsLoadingSuggestions(true);
		try {
			const response = await fetch("/api/suggest", {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({ html: currentHtml }),
			});

			if (!response.ok) {
				throw new Error("Failed to fetch suggestions");
			}

			const suggestions = await response.json();
			setTitle(suggestions.title || "");
			setDescription(suggestions.description || "");
		} catch (error) {
			console.error("Error fetching suggestions:", error);
		} finally {
			setIsLoadingSuggestions(false);
		}
	}, [currentHtml]);

	const shareEnabled = title && description;

	// When status changes to "shared", focus and select the input text.
	useEffect(() => {
		if (status === "shared" && sharedInputRef.current) {
			sharedInputRef.current.focus();
			sharedInputRef.current.select();
		}
	}, [status]);

	useEffect(() => {
		if (version) {
			setStatus("idle");
		}
	}, [version]);

	useEffect(() => {
		if (open && status === "idle" && !title && !description) {
			fetchSuggestions();
		}
	}, [open, status, title, description, fetchSuggestions]);

	return (
		<Popover open={open} onOpenChange={setOpen}>
			<PopoverTrigger asChild>
				<Button
					disabled={disabled || status === "sharing"}
					variant="outline"
					data-tooltip-id="share-tooltip"
					data-tooltip-content={
						status === "sharing"
							? "Sharing..."
							: "Share your app&apos;s code"
					}
				>
					<IoShareOutline size={20} /> Share
				</Button>
			</PopoverTrigger>
			<PopoverContent>
				<div className="flex flex-col justify-center items-center w-full">
					{status === "sharing" && <div>Sharing...</div>}
					{status === "shared" && (
						<div className="flex flex-col justify-center items-center w-full">
							<h2 className="text-lg font-montserrat">Shared!</h2>
							<p className="text-sm text-gray-500 p-3">
								Your app has been shared! You can now share the link with your
								friends.
							</p>
							<div className="flex flex-col gap-2">
								<div className="text-sm font-medium">Link:</div>
								<div className="flex gap-2">
									<Input autoFocus value={url} ref={sharedInputRef} readOnly />
									<Button
										size="icon"
										onClick={() => copyToClipboard(url)}
										className=" shrink-0"
									>
										{isCopied ? <Check size={16} /> : <Copy size={16} />}
									</Button>
								</div>
								<div
									className={cn(
										"text-sm opacity-0 text-center",
										isCopied && "opacity-50",
									)}
								>
									Link copied to clipboard!
								</div>
								<div className="flex gap-2 justify-end">
									<Button variant="outline" onClick={() => setOpen(false)}>
										Close
									</Button>
									<Button onClick={() => window.open(url, "_blank")}>
										Open in new tab
									</Button>
								</div>
							</div>
						</div>
					)}
					{status === "idle" && (
						<div className="flex flex-col gap-6">
							<h2 className="text-lg font-montserrat">Share your app</h2>
							<p className="text-sm text-gray-500">
								{isLoadingSuggestions
									? "Generating suggestions..."
									: "These entries will be shown when you share them around."}
							</p>
							<div className="flex flex-col gap-2">
								<div className="text-sm font-medium">App name:</div>
								<div>
									<Input
										value={title}
										onChange={(e) => setTitle(e.target.value)}
										placeholder="e.g. Rainbow Calculator"
										disabled={isLoadingSuggestions}
									/>
								</div>
							</div>
							<div className="flex flex-col gap-2">
								<div className="text-sm font-medium">
									Describe your app in a few words:
								</div>
								<div>
									<Textarea
										value={description}
										onChange={(e) => setDescription(e.target.value)}
										placeholder="e.g. A calculator that shows the rainbow colors"
										disabled={isLoadingSuggestions}
									/>
								</div>
							</div>
							<div className="flex items-center space-x-2">
								<Checkbox
									id="dontgallery"
									checked={avoidGallery}
									onCheckedChange={(checked) => setAvoidGallery(!!checked)}
								/>
								<label
									htmlFor="dontgallery"
									className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
								>
									Don&apos;t show in gallery
								</label>
							</div>
							<div className="flex justify-end">
								<Button
									onClick={handleShare}
									disabled={!shareEnabled || isLoadingSuggestions}
								>
									Share
								</Button>
							</div>
						</div>
					)}
				</div>
			</PopoverContent>
		</Popover>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/theme-provider.tsx

```ts
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
	children,
	...props
}: React.ComponentProps<typeof NextThemesProvider>) {
	return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/data/app-examples.ts

```ts
interface AppExample {
  label: string;
  prompt: string;
}

export const APP_EXAMPLES: AppExample[] = [
  {
    label: "Calculator",
    prompt: "Create a calculator app with a clean modern design. Include basic arithmetic operations (add, subtract, multiply, divide) and a clear button. The calculator should support decimal numbers and display the current calculation.",
  },
  {
    label: "Todo List",
    prompt: "Build a todo list application with the ability to add, complete, and delete tasks. The add button and input should be integrated on one row. Each task should have a checkbox to mark it as complete. Include a clean input field at the top and a list of todos below. Add subtle animations for completing and removing tasks. Make sure the input element colors are appropriate.",
  },
  {
    label: "Weather App",
    prompt: "Design a weather dashboard that shows the current temperature, weather condition, and other metrics like humidity and wind speed. Use weather-appropriate icons and a clean, modern layout with good visual hierarchy.",
  },
  {
    label: "Quiz App",
    prompt: "Create an interactive quiz application with multiple-choice questions. Include a progress indicator, score tracking, and immediate feedback on answers. Make it visually engaging with appropriate spacing and transitions between questions.",
  },
  {
    label: "Snake Game",
    prompt: "Develop a classic snake game with arrow key controls. Include a score counter, game over screen, and restart button. The snake should grow when eating food, and the game should end if the snake hits the walls or itself. Make sure it is correct and make the JS implementation simple. The spawning algorithm should spawn within the bounds.",
  },
  {
    label: "Note Taker",
    prompt: "Build a note-taking app with a clean, minimal interface. Include a title field and content area for each note. Add the ability to create new notes and preview existing ones in a side panel. Make sure the input fields have specified text colors consistent with the selected theme. Storing notes should be done correctly. Each note should be a separate entry in the object storage.",
  },
  {
    label: "Recipe Finder",
    prompt: "Design a recipe search interface with filters for cuisine type and dietary restrictions. Show recipe cards with images, cooking time, and difficulty level. Include a detailed view for each recipe. State handling should be done correctly.",
  },
  {
    label: "Chatbot",
    prompt: "Create a chatbot interface with a message history display and input field. Messages should alternate between user and bot, with distinct styling for each. Include typing indicators and message timestamps.",
  },
  {
    label: "Space Invaders",
    prompt: "Create a classic Space Invaders game with rows of descending aliens, a player-controlled ship at the bottom, and protective barriers. Implement alien movement patterns, player shooting mechanics, and increasing difficulty as the game progresses. Include a score system, lives counter, and game over conditions when aliens reach the bottom or the player loses all lives. The aliens should also shoot back.",
  },
  {
    label: "Image Gallery",
    prompt: "Design a responsive image gallery with a grid layout. Include image thumbnails that expand to full size when clicked. Add smooth transitions and a lightbox effect for viewing images.",
  },
  {
    label: "Local Audio Player",
    prompt: "Create a simple audio player that allows users to select and play local audio files. Include a file input for selecting audio files, play/pause button, and a progress bar showing the current playback position. Display the file name and duration of the selected track. Ensure the player works with common audio formats like MP3 and WAV.",
  },
  {
    label: "Video Player",
    prompt: "Build a video player with standard controls (play/pause, volume, fullscreen). Include a progress bar with preview thumbnails and playback speed controls. Add a clean, minimal interface that fades when not in use.",
  },
  {
    label: "Calendar",
    prompt: "Design a monthly calendar view with the ability to navigate between months. Show current date highlight and different styling for weekend days. Include a simple event display system.",
  },
  {
    label: "Kanban Board",
    prompt: "Create a Kanban board with 'To Do', 'In Progress', and 'Done' columns. Include an 'Add Task' button (select which board), task cards with titles and descriptions, and drag-and-drop functionality. Use a clean, responsive design with pastel colors and subtle animations. Make it feature complete. Allow dragging between columns. Use in-browser React rendering using Babel. Make sure the input fields have explicit colors set that are compatible with the theme. Use HTML5 native features for drag-and-drop, verify it works correctly. Populate with some SWE examples.",
  },
  {
    label: "Expense Tracker",
    prompt: "Build an expense tracking app with the ability to add transactions with amounts and categories. Show total balance and category-wise breakdown. Include a simple chart to visualize spending patterns.Make sure the input fields have explicit colors set that are compatible with the theme.",
  },
];

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/data/easter-eggs.ts

```ts
interface EasterEgg {
  trigger: string;
  prompt: string;
}

export const EASTER_EGGS: EasterEgg[] = [
  {
    trigger: "groq race",
    prompt: `A race where 3 logos go from left to right. Each logo is on a separate row, but it's a snug fit. Make sure the logos are not overlapping and the page width is used.
				
The logos should have rounded corners. Make them 48px. The text should appear once the Groq logo is at the finish line. 

Only the Groq logo should STOP before the finish line, then we stop updating the position of the other logos.

Use pure JavaScript for the animation.

As a funny joke, put the logos of Cerebras and SambaNova upside down using CSS transforms.

Groq (https://images.crunchbase.com/image/upload/c_pad,h_170,w_170,f_auto,b_white,q_auto:eco,dpr_2/le3jn0kzou7feco18wuo) goes to the finish fastest
SambaNova (https://images.crunchbase.com/image/upload/c_pad,h_170,w_170,f_auto,b_white,q_auto:eco,dpr_2/y85yyhlbrxjtcow3u9es)
Cerebras (https://images.crunchbase.com/image/upload/c_pad,h_170,w_170,f_auto,b_white,q_auto:eco,dpr_2/oxlye0pmonwkanrw206j)
NVIDIA (https://images.crunchbase.com/image/upload/c_pad,h_170,w_170,f_auto,b_white,q_auto:eco,dpr_2/v1502744943/jhowtgkdwv2aa1eodg2b.png)
AMD (https://images.crunchbase.com/image/upload/c_pad,h_170,w_170,f_auto,b_white,q_auto:eco,dpr_2/mexfxtohyewwqg7iq2wl)
Intel (https://images.crunchbase.com/image/upload/c_pad,h_170,w_170,f_auto,b_white,q_auto:eco,dpr_2/qpoiezeptj4q8krro55g)

Make sure it is correct JavaScript, you are an expert coder.

Make sure Groq, SambaNova, Cerabras, NVIDIA, AMD, Intel are all represented. Speeds between 0.2 and 1.0.

Then the text appears: Groq wins!`,
  },
  {
    trigger: "work4groq",
    prompt: `Create a fun, fake job board for Groq with the following elements:

1. A bold header saying "Join the Groq Revolution!"
2. A list of 4-5 ridiculous AI-related job titles in a list (no description). Be creative and humorous!
3. Each job listing should have a fake "Apply Now" button that, when clicked, reveals a silly message.
4. At the bottom of the page, add a small, conspicuous link saying "Psst... Want to join for real? Click here!" that directs to https://job-boards.greenhouse.io/embed/job_board?for=groq`,
  },
  {
    trigger: "higher rate limits",
    prompt: `Create a fun email composition interface with the following elements:

1. A pre-filled "To:" field that says "mgurton@groq.com"
2. A pre-filled "Subject:" field that says "Rate Limit Increase Request"
3. A pre-filled message body that says "Please Mr. Gurton, can I get some higher rate limits plz? üôè"
4. A large "Send" button at the bottom (it doesn't need to actually send)

Style it to look like a modern email interface with good spacing and a clean design.
When the send button is clicked, show a fun animation or message.

Add some playful elements like emoji reactions or a fun background pattern.`,
  },
];

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/hooks/use-copy-to-clipboard.ts

```ts
import * as React from "react";

export interface useCopyToClipboardProps {
	timeout?: number;
}

export function useCopyToClipboard({
	timeout = 2000,
}: useCopyToClipboardProps) {
	const [isCopied, setIsCopied] = React.useState<boolean>(false);

	const copyToClipboard = async (value: string) => {
		if (typeof window === "undefined" || !value) {
			return;
		}

		try {
			// Try using the Clipboard API first
			if (navigator.clipboard?.writeText) {
				await navigator.clipboard.writeText(value);
				setIsCopied(true);
			} else {
				// Fallback for browsers that don't support clipboard API
				const textarea = document.createElement("textarea");
				textarea.value = value;
				textarea.style.position = "fixed";
				textarea.style.left = "-999999px";
				textarea.style.top = "-999999px";
				document.body.appendChild(textarea);
				textarea.focus();
				textarea.select();
				
				try {
					document.execCommand("copy");
					setIsCopied(true);
				} catch (err) {
					console.error("Failed to copy text:", err);
					return;
				} finally {
					document.body.removeChild(textarea);
				}
			}

			setTimeout(() => {
				setIsCopied(false);
			}, timeout);
		} catch (err) {
			console.error("Failed to copy text:", err);
		}
	};

	return { isCopied, copyToClipboard };
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/lib/settings.ts

```ts
export const MAINTENANCE_MODE = false;
export const MAINTENANCE_GENERATION = false;
export const MAINTENANCE_USE_VANILLA_MODEL = false;

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/lib/utils.ts

```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";
import { ROOT_URL } from "@/utils/config";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

export function getOgImageUrl(sessionId: string, version: string) {
	return `https://image.thum.io/get/${ROOT_URL}/api/apps/${sessionId}/${version}/raw`;
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/providers/provider-factory.tsx

```ts
import { type Context, createContext, useContext } from "react";
import type React from "react";
import type { JSX } from "react";

export function providerFactory<T>(
  hook: () => T,
): [({ children }: { children: React.ReactNode }) => JSX.Element, () => T] {
  // 1. Create Context
  const context = createContext<T>({} as T);

  // 2. Create Provider
  const Provider = ({ children }: { children: React.ReactNode }) => {
    const state = hook();
    return <context.Provider value={state}>{children}</context.Provider>;
  };

  // 3. Create Hook
  const useProvider = () => useContextOrDie(context);

  // Expose Provider and Hook
  return [Provider, useProvider];
}

function useContextOrDie<T>(context: Context<T>): T {
  const value = useContext(context);

  if (!value) {
    throw new Error("trying to use context outside a valid context");
  }

  return value;
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/providers/studio-provider.tsx

```ts
import { useState, useRef, useEffect, useCallback } from "react";
import { providerFactory } from "./provider-factory";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";
import { constructPrompt } from "@/utils/prompt";
import { useTheme } from "next-themes";
import { EASTER_EGGS } from "@/data/easter-eggs";
import { MODEL_OPTIONS } from "@/utils/models";
export interface HistoryEntry {
	html: string;
	feedback: string;
	usage?: {
		total_time: number;
		total_tokens: number;
	};
	signature?: string;
	sessionId?: string;
	version?: string;
	reasoning?: string;
}

const [StudioProvider, useStudio] = providerFactory(() => {
	const [query, setQuery] = useState("");
	const [studioMode, setStudioMode] = useState(false);
	const [triggerGeneration, setTriggerGeneration] = useState(false);
	const [currentHtml, setCurrentHtml] = useState("");
	const [currentFeedback, setCurrentFeedback] = useState("");
	const [isOverlayOpen, setIsOverlayOpen] = useState(false);
	const [mode, setMode] = useState<"query" | "feedback">("query");
	const [history, setHistory] = useState<HistoryEntry[]>([]);
	const [historyIndex, setHistoryIndex] = useState(-1);
	const [sessionId, setSessionId] = useState(() => uuidv4());
	const [isGenerating, setIsGenerating] = useState(false);
	const [isApplying, setIsApplying] = useState(false);
	const [drawingData, setDrawingData] = useState<string | null>(null);
	const iframeRef = useRef<HTMLIFrameElement>(null);
	const { resolvedTheme } = useTheme();
	const [feedbackHistory, setFeedbackHistory] = useState<string[]>([]);
	const [feedbackHistoryIndex, setFeedbackHistoryIndex] = useState(-1);
	const [model, setModel] = useState(() => {
		if (typeof window !== "undefined") {
			return localStorage.getItem("selectedModel") || MODEL_OPTIONS[0];
		}
		return MODEL_OPTIONS[0];
	});

	// New streaming state
	const [isStreaming, setIsStreaming] = useState(false);
	const [streamingContent, setStreamingContent] = useState("");
	const [streamingComplete, setStreamingComplete] = useState(false);

	// Effect to update localStorage when model changes
	useEffect(() => {
		if (typeof window !== "undefined" && model) {
			localStorage.setItem("selectedModel", model);
		}
	}, [model]);

	// Helper function to reset streaming state
	const resetStreamingState = () => {
		setIsStreaming(false);
		setStreamingContent("");
		setStreamingComplete(false);
	};

	const generateHtml = useCallback(async () => {
		setIsGenerating(true);
		setIsStreaming(true);
		setStreamingContent("");
		setStreamingComplete(false);
		
		try {
			let currentQuery = query;
			const easterEgg = EASTER_EGGS.find(
				(egg) => egg.trigger.toLowerCase() === query.trim().toLowerCase()
			);
			if (easterEgg) {
				currentQuery = easterEgg.prompt;
				setQuery(currentQuery);
			}

			const response = await fetch("/api/generate", {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					...{
						query: currentQuery,
						currentHtml,
						drawingData,
						theme: resolvedTheme,
						model: model,
						stream: true
					},
					sessionId,
					version: history.length > 0 ? String(history.length + 1) : "1",
				}),
			});

			if (!response.ok) {
				throw new Error("Failed to generate HTML");
			}

			if (response.headers.get("Content-Type")?.includes("text/event-stream")) {
				// Handle streaming response
				const reader = response.body?.getReader();
				const decoder = new TextDecoder();
				
				if (!reader) {
					throw new Error("Failed to get reader from response");
				}
				
				let reasoning = "";
				let done = false;
				let html = "";
				let signature = "";
				
				while (!done) {
					const { value, done: readerDone } = await reader.read();
					done = readerDone;
					
					if (value) {
						const text = decoder.decode(value);
						const lines = text.split("\n").filter(line => line.trim());
						
						for (const line of lines) {
							try {
								const data = JSON.parse(line);
								
								if (data.type === "chunk") {
									// Simply append the new content to our streamingContent state
									setStreamingContent(prev => prev + data.content);
									// Also update reasoning for history
									reasoning += data.content;
								} else if (data.type === "complete") {
									html = data.html;
									signature = data.signature;
									setStreamingComplete(true);
								} else if (data.type === "error") {
									throw new Error(data.error);
								}
							} catch (e) {
								console.error("Error parsing streaming response:", e);
							}
						}
					}
				}
				
				const newEntry: HistoryEntry = {
					html,
					feedback: "",
					reasoning,
					sessionId,
					version: String(history.length + 1),
					signature,
				};
				
				setHistory((prev) => [...prev, newEntry]);
				setHistoryIndex((prev) => prev + 1);
				setCurrentHtml(html);
				setMode("feedback");
			} else {
				const result = await response.json();
				
				const newEntry: HistoryEntry = {
					html: result.html,
					feedback: "",
					usage: {
						total_time: result.usage?.total_time || 0,
						total_tokens: result.usage?.total_tokens || 0
					},
					sessionId,
					version: String(history.length + 1),
					signature: result.signature,
				};
				
				setHistory((prev) => [...prev, newEntry]);
				setHistoryIndex((prev) => prev + 1);
				setCurrentHtml(result.html);
				setMode("feedback");
			}
		} catch (error) {
			console.error("Error generating HTML:", error);
			toast.error("Failed to generate HTML");
		} finally {
			setIsGenerating(false);
			setIsStreaming(false);
		}
	}, [query, currentHtml, resolvedTheme, sessionId, history, setHistory, setHistoryIndex, setCurrentHtml, setMode, setQuery, drawingData, model]);

	const submitFeedback = async () => {
		setIsApplying(true);
		setIsStreaming(true);
		setStreamingContent("");
		setStreamingComplete(false);
		
		try {
			if (currentFeedback.trim()) {
				// Add to feedback history, deduplicating entries
				setFeedbackHistory(prev => {
					const trimmedFeedback = currentFeedback.trim();
					// Remove any existing instances of this feedback
					const dedupedHistory = prev.filter(f => f !== trimmedFeedback);
					// Add the new feedback at the start
					return [trimmedFeedback, ...dedupedHistory];
				});
				setFeedbackHistoryIndex(-1);

				// Update history entry with new feedback
				const updatedHistory = [...history];
				updatedHistory[historyIndex] = {
					...updatedHistory[historyIndex],
					feedback: currentFeedback.trim(),
				};
				setHistory(updatedHistory);

				const response = await fetch("/api/generate", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
					},
					body: JSON.stringify({
						currentHtml: history[historyIndex].html,
						feedback: currentFeedback.trim(),
						theme: resolvedTheme,
						stream: true,
						model: model,
						sessionId,
						version: history.length > 0 ? String(history.length + 1) : "1",
					}),
				});

				if (!response.ok) {
					if (response.status === 400) {
						const data = await response.json();
						if (data.category) {
							toast.error(
								<div>
									<p>{data.error}</p>
									<p className="text-sm text-gray-500 mt-1">
										Category: {data.category}
									</p>
								</div>,
								{ duration: 5000 },
							);
							return;
						}
					}
					throw new Error("Failed to generate HTML");
				}

				if (response.headers.get("Content-Type")?.includes("text/event-stream")) {
					// Handle streaming response
					const reader = response.body?.getReader();
					const decoder = new TextDecoder();
					
					if (!reader) {
						throw new Error("Failed to get reader from response");
					}
					
					let reasoning = "";
					let done = false;
					let html = "";
					let signature = "";
					
					while (!done) {
						const { value, done: readerDone } = await reader.read();
						done = readerDone;
						
						if (value) {
							const text = decoder.decode(value);
							const lines = text.split("\n").filter(line => line.trim());
							
							for (const line of lines) {
								try {
									const data = JSON.parse(line);
									
									if (data.type === "chunk") {
										// Simply append the new content to our streamingContent state
										setStreamingContent(prev => prev + data.content);
										// Also update reasoning for history
										reasoning += data.content;
									} else if (data.type === "complete") {
										html = data.html;
										signature = data.signature;
										setStreamingComplete(true);
									} else if (data.type === "error") {
										throw new Error(data.error);
									}
								} catch (e) {
									console.error("Error parsing streaming response:", e);
								}
							}
						}
					}
					
					// Create new history entry with the final HTML
					const version = (history.length + 1).toString();
					const newEntry: HistoryEntry = {
						html,
						feedback: "",
						reasoning,
						signature,
						sessionId: history[historyIndex].sessionId,
						version,
					};
					
					const newHistory = [...history.slice(0, historyIndex + 1), newEntry];
					setHistory(newHistory);
					setHistoryIndex(newHistory.length - 1);
					setCurrentHtml(html);
					setCurrentFeedback("");
				} else {
					// Handle non-streaming response (fallback)
					const data = await response.json();
					
					if (data.html) {
						const version = (history.length + 1).toString();
						const newEntry: HistoryEntry = {
							html: data.html,
							feedback: "",
							usage: data.usage,
							signature: data.signature,
							sessionId: history[historyIndex].sessionId,
							version,
						};
						const newHistory = [...history.slice(0, historyIndex + 1), newEntry];
						setHistory(newHistory);
						setHistoryIndex(newHistory.length - 1);
						setCurrentHtml(data.html);
						setCurrentFeedback("");
					}
				}
			}
		} catch (error) {
			console.error("Error:", error);
			toast.error("Failed to apply edit");
		} finally {
			setIsApplying(false);
			setIsStreaming(false);
		}
	};

	const navigateHistory = (direction: "prev" | "next") => {
		// Reset streaming state when navigating history
		resetStreamingState();
		
		const newIndex = direction === "prev" ? historyIndex - 1 : historyIndex + 1;
		if (newIndex >= 0 && newIndex < history.length) {
			setHistoryIndex(newIndex);
			setCurrentHtml(history[newIndex].html);
			setCurrentFeedback(history[newIndex].feedback || "");
		}
	};

	const getFormattedOutput = () => {
		return constructPrompt({
			query,
			currentFeedback,
			currentHtml,
			theme: resolvedTheme,
		});
	};

	useEffect(() => {
		const handleKeyPress = (e: KeyboardEvent) => {
			if (e.key === "Escape") {
				setIsOverlayOpen(false);
			}
		};

		window.addEventListener("keydown", handleKeyPress);
		return () => window.removeEventListener("keydown", handleKeyPress);
	}, []);

	useEffect(() => {
		if (triggerGeneration) {
			setTriggerGeneration(false);
			generateHtml();
		}
	}, [triggerGeneration, setTriggerGeneration, generateHtml]);

	useEffect(() => {
		if (!studioMode) {
			resetStreamingState();
		}
	}, [studioMode]);

	useEffect(() => {
		resetStreamingState();
	}, [sessionId]);

	// Add a new effect to reset streaming state when historyIndex changes
	useEffect(() => {
		if (historyIndex >= 0) {
			resetStreamingState();
		}
	}, [historyIndex]);

	// Add a cleanup effect to reset streaming state when component unmounts
	useEffect(() => {
		return () => {
			resetStreamingState();
		};
	}, []);

	return {
		query,
		setQuery,
		studioMode,
		setStudioMode,
		triggerGeneration,
		setTriggerGeneration,
		history,
		setHistory,
		historyIndex,
		setHistoryIndex,
		navigateHistory,
		mode,
		setMode,
		currentHtml,
		setCurrentHtml,
		currentFeedback,
		setCurrentFeedback,
		isOverlayOpen,
		setIsOverlayOpen,
		isGenerating,
		setIsGenerating,
		isApplying,
		setIsApplying,
		generateHtml,
		submitFeedback,
		getFormattedOutput,
		iframeRef,
		sessionId,
		setSessionId,
		drawingData,
		setDrawingData,
		feedbackHistory,
		setFeedbackHistory,
		feedbackHistoryIndex,
		setFeedbackHistoryIndex,
		model,
		setModel,
		isStreaming,
		setIsStreaming,
		streamingContent,
		setStreamingContent,
		streamingComplete,
		setStreamingComplete,
		resetStreamingState,
	};
});

export { StudioProvider, useStudio };

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/server/signing.ts

```ts
import crypto from "node:crypto";

// It's assumed you've loaded your .env file before running this code
const secretKey = process.env.HTML_SIGNING_SECRET;

if (!secretKey) {
	throw new Error("HTML_SIGNING_SECRET not found in environment variables");
}

/**
 * Sign the given HTML using an HMAC with SHA-256.
 * @param html The HTML string to sign.
 * @returns A hex-encoded signature string.
 */
export function signHtml(html: string): string {
	const hmac = crypto.createHmac("sha256", secretKey);
	hmac.update(html, "utf8");
	return hmac.digest("hex");
}

/**
 * Verify the given HTML against a provided signature.
 * @param html The HTML string to verify.
 * @param signature The signature received along with the HTML.
 * @returns true if the signature matches, false otherwise.
 */
export function verifyHtml(html: string, signature: string): boolean {
	if (!html || !signature) {
		return false;
	}
	try {
		const expectedSignature = signHtml(html);
		return crypto.timingSafeEqual(
			Buffer.from(signature, "hex"),
			Buffer.from(expectedSignature, "hex"),
		);
	} catch (error) {
		console.error("Error verifying HTML:", error);
		return false;
	}
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/server/storage.ts

```ts
import { Redis } from "ioredis";
import crypto from "crypto";
import { createClient } from '@supabase/supabase-js';

interface GalleryItem {
	sessionId: string;
	version: string;
	title: string;
	description: string;
	upvotes?: number; // Number of upvotes
	createdAt: string; // ISO date string
	signature: string;
}

function hashIP(ip: string): string {
	return crypto.createHash('sha256').update(ip).digest('hex').substring(0, 8);
}

const supabase = createClient(
	process.env.SUPABASE_URL!,
	process.env.SUPABASE_KEY!,
	{
		auth: {
			persistSession: false,
		}
	}
);

// Cache for gallery items
interface GalleryCache {
	items: GalleryItem[];
	lastFetch: number;
}

let galleryCache: GalleryCache | null = null;

export async function getGallery(): Promise<GalleryItem[]> {
	const now = Date.now();
	const CACHE_TTL = 30 * 1000;

	if (galleryCache && (now - galleryCache.lastFetch) < CACHE_TTL) {
		return galleryCache.items;
	}

	// Get all gallery items with pagination
	let allItems = [];
	let page = 0;
	const PAGE_SIZE = 1000;
	
	while (true) {
		const { data: items, error } = await supabase
			.from('gallery_items')
			.select(`
				id,
				session_id,
				version,
				title,
				description,
				signature,
				created_at
			`)
			.range(page * PAGE_SIZE, (page + 1) * PAGE_SIZE - 1)
			.order('created_at', { ascending: false });

		if (error) throw error;
		if (!items || items.length === 0) break;
		
		allItems.push(...items);
		if (items.length < PAGE_SIZE) break;
		page++;
	}

	// Get all upvotes with pagination
	let allUpvotes = [];
	page = 0;
	
	while (true) {
		const { data: upvotes, error: upvoteError } = await supabase
			.from('upvotes')
			.select('gallery_item_id')
			.range(page * PAGE_SIZE, (page + 1) * PAGE_SIZE - 1);

		if (upvoteError) throw upvoteError;
		if (!upvotes || upvotes.length === 0) break;
		
		allUpvotes.push(...upvotes);
		if (upvotes.length < PAGE_SIZE) break;
		page++;
	}

	// Count upvotes per gallery item
	const upvoteCounts = new Map();
	allUpvotes.forEach(vote => {
		const count = upvoteCounts.get(vote.gallery_item_id) || 0;
		upvoteCounts.set(vote.gallery_item_id, count + 1);
	});

	// Transform to GalleryItem format
	const galleryItems: GalleryItem[] = allItems.map(item => ({
		sessionId: item.session_id,
		version: item.version,
		title: item.title,
		description: item.description,
		signature: item.signature,
		createdAt: item.created_at,
		upvotes: upvoteCounts.get(item.id) || 0
	}));

	galleryCache = {
		items: galleryItems,
		lastFetch: now
	};

	return galleryItems;
}

export async function getUpvotes(sessionId: string, version: string): Promise<number> {
	// First get the gallery item ID
	const { data: item, error: itemError } = await supabase
		.from('gallery_items')
		.select('id')
		.eq('session_id', sessionId)
		.eq('version', version)
		.single();

	if (itemError) throw itemError;
	if (!item) throw new Error("Gallery item not found");

	// Then count upvotes for this item
	const { count, error: countError } = await supabase
		.from('upvotes')
		.select('*', { count: 'exact', head: true })
		.eq('gallery_item_id', item.id);

	if (countError) throw countError;
	return count || 0;
}

export async function isIPBlocked(ip: string): Promise<boolean> {
	const { count, error } = await supabase
		.from('blocked_ips')
		.select('*', { count: 'exact', head: true })
		.eq('ip_address', ip);

	if (error) throw error;
	return (count || 0) > 0;

}

// Helper function to get gallery item by session and version
export async function getGalleryItem(sessionId: string, version: string) {
	const { data, error } = await supabase
		.from('gallery_items')
		.select('id, session_id, version, title, description, signature, created_at, creator_ip_hash')
		.eq('session_id', sessionId)
		.eq('version', version)
		.single();

	if (error) throw error;
	return data;
}

// Legacy Redis function - no longer used
export function getStorageKey(sessionId: string, version: string, ip?: string): string {
	if (!ip) {
		return `${sessionId}/${version}/*`;
	}
	const ipHash = hashIP(ip);
	return `${sessionId}/${version}/${ipHash}`;
}

// Legacy Redis function - no longer used
function getGalleryKey(timestamp: number, randomHash: string, ip: string): string {
	const ipHash = hashIP(ip);
	return `gallery_${timestamp}_${randomHash}_${ipHash}`;
}

// Legacy Redis function - no longer used
export async function saveToStorage(key: string, value: string) {
	const redis = new Redis(process.env.UPSTASH_REDIS_URL);
	await redis.set(key, value);
}

// Legacy Redis function - no longer used
export async function getFromStorage(key: string) {
	const redis = new Redis(process.env.UPSTASH_REDIS_URL);
	const value = await redis.get(key);
	return value;
}

// Legacy Redis function - no longer used
export async function getFromStorageWithRegex(key: string): Promise<{value: string, key: string}> {
	const redis = new Redis(process.env.UPSTASH_REDIS_URL);
	const keys = await redis.keys(key);
	if(keys.length === 0) {
		throw new Error("Not found");
	}
	
	return {value: await getFromStorage(keys[0]), key: keys[0]};
}

// Legacy Redis function - no longer used
export async function getGalleryKeys(): Promise<string[]> {
	const redis = new Redis(process.env.UPSTASH_REDIS_URL);
	const keys: string[] = [];
	let cursor = 0;
	const count = 10000;
	let batch = [];
	do {
		const resp = await redis.scan(cursor, "MATCH", "gallery_*", "COUNT", count);
		batch = resp[1];
		cursor += count;
		keys.push(...batch);
	} while (batch.length > 0);

	return keys.sort().reverse(); // Sort in descending order to get latest first
}

// Legacy Redis function - no longer used
export async function getBlockedIPs(): Promise<string[]> {
	const blockedIPsStr = await getFromStorage("blocked_ips");
	return blockedIPsStr ? JSON.parse(blockedIPsStr) : [];
}

export async function blockIP(ip: string, token: string) {
	if (token !== process.env.BLOCK_SECRET) {
		throw new Error("Invalid token");
	}

	// Add IP to blocked_ips table
	const { error: blockError } = await supabase
		.from('blocked_ips')
		.upsert({
			ip_address: ip
		});

	if (blockError) throw blockError;

	// Get all gallery items created by this IP
	const { data: items, error: itemsError } = await supabase
		.from('gallery_items')
		.select('id')
		.eq('creator_ip_hash', hashIP(ip));

	if (itemsError) throw itemsError;

	if (items && items.length > 0) {
		// Delete all gallery items by this IP (cascade will handle upvotes)
		const { error: deleteError } = await supabase
			.from('gallery_items')
			.delete()
			.eq('creator_ip_hash', hashIP(ip));

		if (deleteError) throw deleteError;
	}

	// Clear the gallery cache
	galleryCache = null;
}

export async function addToGallery(item: GalleryItem, creatorIP: string): Promise<boolean> {
	// Ensure createdAt is set
	item.createdAt = item.createdAt || new Date().toISOString();
	const creatorIpHash = hashIP(creatorIP);

	// Insert into gallery_items table
	const { data: galleryItem, error: insertError } = await supabase
		.from('gallery_items')
		.upsert({
			session_id: item.sessionId,
			version: item.version,
			title: item.title,
			description: item.description,
			signature: item.signature,
			created_at: item.createdAt,
			creator_ip_hash: creatorIpHash
		})
		.select()
		.single();

	if (insertError) throw insertError;
	if (!galleryItem) throw new Error("Failed to add gallery item");

	// Clear the gallery cache to ensure fresh data on next fetch
	galleryCache = null;

	return true;
}

export async function removeGalleryItem(sessionId: string, version: string, requestIP: string): Promise<boolean> {
	let redisSuccess = false;
	let supabaseSuccess = false;

	try {
		// Try Redis removal first
		try {
			const key = getStorageKey(sessionId, version);
			const { value } = await getFromStorageWithRegex(key);
			
			if (value) {
				const data = JSON.parse(value);
				if (data.creatorIP !== requestIP) {
					throw new Error("Unauthorized: You can only remove your own submissions");
				}

				const redis = new Redis(process.env.REDIS_URL!);
				await redis.del(key);
				await redis.quit();
				redisSuccess = true;
			}
		} catch (error) {
			if (error instanceof Error && error.message.includes("Unauthorized")) {
				throw error;
			}
			// Log but continue if Redis fails
			console.error("Redis removal error:", error);
		}

		// Try Supabase removal
		try {
			const requestIpHash = hashIP(requestIP);

			const { data: item, error: selectError } = await supabase
				.from('gallery_items')
				.select('id, creator_ip_hash')
				.eq('session_id', sessionId)
				.eq('version', version)
				.single();

			if (!selectError && item) {
				if (item.creator_ip_hash !== requestIpHash) {
					throw new Error("Unauthorized: You can only remove your own submissions");
				}

				const { error: deleteError } = await supabase
					.from('gallery_items')
					.delete()
					.eq('id', item.id);

				if (!deleteError) {
					supabaseSuccess = true;
					galleryCache = null; // Clear gallery cache on successful removal
				}
			}
		} catch (error) {
			if (error instanceof Error && error.message.includes("Unauthorized")) {
				throw error;
			}
			// Log but continue if Supabase fails
			console.error("Supabase removal error:", error);
		}

		// Return true if at least one storage removal succeeded
		return redisSuccess || supabaseSuccess;
	} catch (error) {
		console.error('Error in removeGalleryItem:', error);
		throw error;
	}
}

export async function upvoteGalleryItem(
	sessionId: string, 
	version: string, 
	voterIp: string,
	timestamp: string
): Promise<number> {

	// First get the gallery item ID
	const { data: item, error: itemError } = await supabase
		.from('gallery_items')
		.select('id')
		.eq('session_id', sessionId)
		.eq('version', version)
		.single();

	if (itemError) throw itemError;
	if (!item) throw new Error("Gallery item not found");

	// Check if this IP has already voted
	const { count: existingVote, error: voteCheckError } = await supabase
		.from('upvotes')
		.select('*', { count: 'exact', head: true })
		.eq('gallery_item_id', item.id)
		.eq('ip_address', voterIp);

	if (voteCheckError) throw voteCheckError;
	if (existingVote) throw new Error("Already voted");


	// Add the upvote with timestamp
	const { error: upvoteError } = await supabase
		.from('upvotes')
		.insert({
			gallery_item_id: item.id,

			ip_address: voterIp,
			created_at: timestamp
		});

	if (upvoteError) throw upvoteError;

	// Clear the gallery cache
	galleryCache = null;

	// Return new upvote count
	return await getUpvotes(sessionId, version);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/utils/config.ts

```ts
export const ROOT_URL = "https://appgen.groqlabs.com";
```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/utils/models.ts

```ts
interface ModelConfig {
    name: string;
    temperature: number;
    type: "text" | "vision";
    maxTokens?: number;
}

const MODEL_CONFIGS: { [key: string]: ModelConfig } = {
    "llama3.2-vision": {
        name: "llama3.2-vision",
        temperature: 0.1,
        type: "vision"
    },
    "llama3.2": {
        name: "llama3.2",
        temperature: 0.1,
        type: "text"
    }
};

// Default temperature if model not found in configs
const DEFAULT_TEMPERATURE = 0.1;
const DEFAULT_MAX_TOKENS = 8192;

// Export only text-based models for MODEL_OPTIONS
export const MODEL_OPTIONS = Object.entries(MODEL_CONFIGS)
    .filter(([_, config]) => config.type === "text")
    .map(([key, _]) => key);

export function getModelTemperature(modelName: string): number {
    return MODEL_CONFIGS[modelName]?.temperature ?? DEFAULT_TEMPERATURE;
}

export function getModelMaxTokens(modelName: string): number {
    return MODEL_CONFIGS[modelName]?.maxTokens ?? DEFAULT_MAX_TOKENS;
}

export function getModelConfig(modelName: string): ModelConfig {
    return MODEL_CONFIGS[modelName] ?? {
        name: modelName,
        temperature: DEFAULT_TEMPERATURE,
        type: "text"
    };
}

export function getFallbackModel(): string {
    // Use same model for fallback
    return "llama3.2";
}

export const PRIMARY_MODEL = "llama3.2";
export const VANILLA_MODEL = "llama3.2";

export const PRIMARY_VISION_MODEL = "llama3.2-vision";
export const FALLBACK_VISION_MODEL = "llama3.2-vision";

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/utils/prompt.ts

```ts
interface PromptData {
  query?: string;
  currentHtml?: string;
  currentFeedback?: string;
  theme?: string;
}

export function constructPrompt(data: PromptData): string {
  const { query = '', currentHtml = '', currentFeedback = '', theme = '' } = data;
  const hasFeedback = currentFeedback.length > 0;

  const themeInstructions = query.length > 0 ? `The app should follow the user's ${theme} theme preference. ${theme === 'dark' ? 'Use darker background colors and lighter text colors.' : theme === 'light' ? 'Use lighter background colors and darker text colors.' : 'Use a neutral color scheme that works well in both light and dark modes.'} Make sure the colors have good contrast and are accessible.` : '';

  const finalPrompt = `${currentHtml ? `<current html>${currentHtml}</current html>` : ''}
${currentFeedback ? `<feedback>${currentFeedback}</feedback>` : ''}
${!hasFeedback && query ? `<query>Generate a single HTML file based on this query: "${query}"</query>` : ''}
${`<output instructions>
The output should be valid HTML and should be creative and well-structured. Use Tailwind CSS, load it in the <head> tag with <script src="https://cdn.tailwindcss.com"></script>.

${themeInstructions}

Return the HTML content wrapped in triple backticks with 'html' language specifier, like this:
\`\`\`html
<your html code here>
\`\`\`
</output instructions>`}
`.trim();

  return finalPrompt;
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/button.tsx

```ts
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/card.tsx

```ts
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/checkbox.tsx

```ts
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/dialog.tsx

```ts
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/dropdown-menu.tsx

```ts
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/input.tsx

```ts
import * as React from "react";

import { cn } from "@/lib/utils";

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
	({ className, type, ...props }, ref) => {
		return (
			<input
				type={type}
				className={cn(
					"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Input.displayName = "Input";

export { Input };

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/popover.tsx

```ts
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/spinner.tsx

```ts
"use client";

import { cn } from "@/lib/utils";

export function Spinner({ className }: { className?: string }) {
  return (
    <div
      className={cn(
        "inline-block h-4 w-4 animate-spin rounded-full border-2 border-solid border-current border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]",
        className
      )}
      role="status"
    >
      <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
        Loading...
      </span>
    </div>
  );
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/tabs.tsx

```ts
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/components/ui/textarea.tsx

```ts
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[120px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/block/page.tsx

```ts
"use client";

import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { ROOT_URL } from "@/utils/config";

export default function BlockPage({
  searchParams,
}: {
  searchParams: { ip: string; token: string };
}) {
  const handleBlock = async () => {
    try {
      const response = await fetch(
        `${ROOT_URL}/api/block?ip=${encodeURIComponent(
          searchParams.ip
        )}&token=${encodeURIComponent(searchParams.token)}`,
        {
          method: "GET",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to block IP");
      }

      // Redirect to home page after successful block
      window.location.href = ROOT_URL;
    } catch (error) {
      console.error("Error blocking IP:", error);
      alert("Failed to block IP. Please try again.");
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-background p-4">
      <Card className="w-full max-w-md p-6 space-y-4">
        <h1 className="text-2xl font-bold text-center">Confirm Block Action</h1>
        <p className="text-center text-muted-foreground">
          Are you sure you want to block this IP address? This action cannot be
          undone.
        </p>
        <div className="flex justify-center space-x-4">
          <Button
            variant="destructive"
            onClick={handleBlock}
          >
            Confirm Block
          </Button>
          <Button
            variant="outline"
            onClick={() => window.history.back()}
          >
            Cancel
          </Button>
        </div>
      </Card>
    </div>
  );
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/gallery-listing.tsx

```ts
import { cn } from "@/lib/utils";
import Link from "next/link";
import useSWR from "swr";
import { getOgImageUrl } from "@/lib/utils";
import { ThumbsUp, Clock } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { Spinner } from "@/components/ui/spinner";

interface GalleryItemWithUpvotes {
	sessionId: string;
	version: string;
	title: string;
	description: string;
	upvoteCount: number;
	createdAt: string;
}

interface GalleryListingProps {
	limit?: number;
	view?: "trending" | "popular" | "new";
}

export function GalleryListing({
	limit,
	view = "popular",
}: GalleryListingProps) {
	const { data: gallery, isLoading } = useSWR<GalleryItemWithUpvotes[]>(
		view ? `/api/apps?view=${view}` : null,
		async (url) => {
			const response = await fetch(url);
			if (!response.ok) {
				throw new Error("Failed to fetch gallery");
			}
			return response.json();
		},
		{
			revalidateOnFocus: false,
			dedupingInterval: 30000, // Match the server-side cache of 30 seconds
		},
	);

	if (isLoading) {
		return (
			<div className="text-center text-gray-500 py-8">
				<Spinner className="mx-auto" />
			</div>
		);
	}

	if (!gallery?.length) {
		return (
			<div className="text-center text-gray-500 py-8">
				{view === "trending"
					? "No trending apps in the last 24 hours"
					: "No apps found"}
			</div>
		);
	}

	return (
		<div className="grid grid-cols-[repeat(auto-fill,minmax(150px,1fr))] md:grid-cols-[repeat(auto-fill,minmax(200px,1fr))] xl:grid-cols-[repeat(auto-fill,minmax(250px,1fr))] gap-4 md:gap-6 xl:gap-8 justify-items-center">
			{(limit ? gallery.slice(0, limit) : gallery).map((item) => (
				<div
					key={item.sessionId}
					className="relative bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow"
				>
					<Link
						href={`/apps/${item.sessionId}/${item.version}`}
						target="_blank"
						className="block w-[150px] md:w-[200px] xl:w-[250px]"
					>
						<div
							className={cn(
								"bg-blue-500 h-[150px] bg-[url('/images/placeholder.png')] bg-cover bg-center",
								"h-[150px] md:h-[200px] xl:h-[250px]",
							)}
							style={{
								backgroundImage: `url(${getOgImageUrl(item.sessionId, item.version)})`,
							}}
						/>
						<div className="p-2 flex flex-col gap-2">
							<div className="flex justify-between items-start gap-2">
								<div className="flex-1 min-w-0">
									<div className="text-sm truncate" title={item.title}>
										{item.title}
									</div>
								</div>
								<div className="flex items-center gap-1 text-sm opacity-70 shrink-0">
									<ThumbsUp size={14} />
									<span>{item.upvoteCount}</span>
								</div>
							</div>
							<div className="text-xs opacity-50 h-[95px] overflow-hidden text-ellipsis line-clamp-6">
								{item.description}
							</div>
							<div className="flex items-center gap-1 text-xs opacity-50 mt-auto">
								<Clock size={12} />
								<span>{formatDistanceToNow(new Date(item.createdAt))} ago</span>
							</div>
						</div>
					</Link>
				</div>
			))}
		</div>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/main-view.tsx

```ts
import { useEffect } from "react";
import PromptView from "./prompt-view";
import StudioView from "./studio-view";
import { useStudio } from "@/providers/studio-provider";

export default function MainView() {
	const { studioMode, setStudioMode } = useStudio();

	useEffect(() => {
		if (location.search.startsWith("?source=")) {
			setStudioMode(true);
		}
	}, [setStudioMode]);

	if (studioMode) {
		return <StudioView />;
	}

	return <PromptView />;
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/new-button.tsx

```ts
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { useStudio } from "@/providers/studio-provider";
import { Plus } from "lucide-react";
import { useRouter } from "next/navigation";
import { v4 as uuidv4 } from "uuid";

export function NewButton({ className }: { className?: string }) {
	const {
		setStudioMode,
		setQuery,
		setHistory,
		setHistoryIndex,
		setCurrentHtml,
		setSessionId,
		setMode,
		setCurrentFeedback,
		resetStreamingState,
	} = useStudio();
	const router = useRouter();

	const handleClick = () => {
		setStudioMode(false);
		setQuery("");
		setHistory([]);
		setHistoryIndex(-1);
		setCurrentHtml("");
		setSessionId(uuidv4());
		setMode("query");
		setCurrentFeedback("");
		resetStreamingState();
		router.push("/");
	};

	return (
		<>
			{/* Mobile view - just the icon */}
			<button
				onClick={handleClick}
				className={cn("lg:hidden text-foreground px-2", className)}
			>
				<Plus size={20} />
			</button>

			{/* Desktop view - full button */}
			<Button
				className={cn("hidden lg:flex items-center gap-2", className)}
				onClick={handleClick}
			>
				<Plus size={16} />
				<span>New</span>
			</Button>
		</>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/options-button.tsx

```ts
import { Button } from "@/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import { useStudio } from "@/providers/studio-provider";
import { Ellipsis } from "lucide-react";

export function OptionsButton({ className }: { className?: string }) {
	const { setIsOverlayOpen, isOverlayOpen } = useStudio();
	return (
		<DropdownMenu>
			<DropdownMenuTrigger asChild>
				{/* Mobile view - just the icon */}
				<button className={cn("lg:hidden text-foreground px-2", className)}>
					<Ellipsis size={20} />
				</button>
			</DropdownMenuTrigger>
			<DropdownMenuContent>
				<DropdownMenuItem onClick={() => setIsOverlayOpen(!isOverlayOpen)}>
					Show prompt
				</DropdownMenuItem>
			</DropdownMenuContent>
		</DropdownMenu>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/prompt-input.tsx

```ts
import { Input } from "@/components/ui/input";
import { useStudio } from "@/providers/studio-provider";
import { SubmitButton } from "./submit-button";
import { MicrophoneButton } from "@/components/MicrophoneButton";
import { useEffect, useRef } from "react";

export function PromptInput() {
	const {
		mode,
		query,
		currentFeedback,
		setQuery,
		setCurrentFeedback,
		generateHtml,
		submitFeedback,
		feedbackHistory,
		feedbackHistoryIndex,
		setFeedbackHistoryIndex,
	} = useStudio();

	const shouldTriggerRef = useRef(false);

	useEffect(() => {
		if (shouldTriggerRef.current) {
			if (mode === "query") {
				generateHtml();
			} else {
				submitFeedback();
			}
			shouldTriggerRef.current = false;
		}
	}, [query, currentFeedback, mode, generateHtml, submitFeedback]);

	const handleTranscription = (transcription: string) => {
		shouldTriggerRef.current = true;
		if (mode === "query") {
			setQuery(transcription);
		} else {
			setCurrentFeedback(transcription);
		}
	};

	return (
		<div className="flex items-center gap-2 flex-1 border-border border focus-within:border-groq rounded-full p-1">
			<Input
				autoFocus
				type="text"
				value={mode === "query" ? query : currentFeedback}
				onChange={(e) =>
					mode === "query"
						? setQuery(e.target.value)
						: setCurrentFeedback(e.target.value)
				}
				className="flex-1 p-2 border-0 rounded focus:border-0 focus:ring-0 focus-visible:ring-0 focus-visible:border-0"
				placeholder={
					mode === "query" ? "Describe your app..." : "Enter your feedback..."
				}
				onKeyDown={(e) => {
					if (e.key === "Enter" && !e.shiftKey) {
						e.preventDefault();
						mode === "query" ? generateHtml() : submitFeedback();
					} else if (mode === "feedback") {
						if (e.key === "ArrowUp") {
							e.preventDefault();
							const newIndex = feedbackHistoryIndex + 1;
							if (newIndex < feedbackHistory.length) {
								setFeedbackHistoryIndex(newIndex);
								setCurrentFeedback(feedbackHistory[newIndex]);
							}
						} else if (e.key === "ArrowDown") {
							e.preventDefault();
							const newIndex = feedbackHistoryIndex - 1;
							if (newIndex >= -1) {
								setFeedbackHistoryIndex(newIndex);
								setCurrentFeedback(newIndex === -1 ? "" : feedbackHistory[newIndex]);
							}
						}
					}
				}}
			/>
			<MicrophoneButton onTranscription={handleTranscription} />
			<div className="flex-shrink-0">
				<SubmitButton />
			</div>
		</div>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/prompt-view.tsx

```ts
import AppLogo from "@/components/AppLogo";
import { MicrophoneButton } from "@/components/MicrophoneButton";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useStudio } from "@/providers/studio-provider";
import { DrawingCanvas } from "@/components/DrawingCanvas";
import { useState } from "react";
import { APP_EXAMPLES } from "@/data/app-examples";
import { Info, Pencil } from "lucide-react";
import Link from "next/link";
import toast from "react-hot-toast";
import ModelSelector from "@/components/model-selector";
import Groq_bolt from "public/groq_bolt.svg"
import { GalleryListing } from "./gallery-listing";
import { MAINTENANCE_GENERATION } from "@/lib/settings";
import { MODEL_OPTIONS } from "@/utils/models";
const APP_SUGGESTIONS = APP_EXAMPLES.map((example) => example.label);


export default function PromptView() {
	const {
		setStudioMode,
		query,
		setQuery,
		setTriggerGeneration,
		drawingData,
		setDrawingData,
		model,
		setModel,
		resetStreamingState,
	} = useStudio();
	const [showDrawing, setShowDrawing] = useState(false);
	const [selectedModel, setSelectedModel] = useState(() => {
		if (typeof window !== "undefined") {
			return localStorage.getItem("selectedModel") || MODEL_OPTIONS[0];
		}
		return MODEL_OPTIONS[0];
	});

	const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
		e.preventDefault();
		if (!query.trim() && !drawingData) {
			toast.error("Describe your app or draw it!");
			return;
		}
		resetStreamingState();
		
		setStudioMode(true);
		setTriggerGeneration(true);
	};

	const handleDrawingComplete = async (imageData: string) => {
		setDrawingData(imageData);
		setShowDrawing(false);
	};

	const handleSuggestionClick = (suggestion: string) => () => {
		const example = APP_EXAMPLES.find((ex) => ex.label === suggestion);
		setQuery(example?.prompt || suggestion);
		
		resetStreamingState();
		
		setStudioMode(true);
		setTriggerGeneration(true);
	};

	const handleTranscription = (transcription: string) => {
		setQuery(transcription);
		
		resetStreamingState();
		
		setStudioMode(true);
		setTriggerGeneration(true);
	};



	return (
		<div className="flex flex-col gap-6 items-center justify-center">
			<AppLogo className="self-start mt-10 ml-10" size={120} />
			<div className="flex flex-col gap-3 items-center justify-center min-w-[50%] px-4 md:px-0 mt-10">
			<div>
					<h1 className="text-[2em] md:text-[3em] font-montserrat text-center">
						Build a micro-app
					</h1>
					<h2 className="text-[1.2em] md:text-[1.4em] font-montserrat mb-4 md:mb-8 text-center text-muted-foreground flex items-center justify-center gap-2">
					at Groq speed
						<img src="/Groq_Bolt.svg" alt="Groq Logo" className="w-8 h-8" />
					</h2>
				</div>
				{MAINTENANCE_GENERATION && (
					<div className="text-center text-gray-500 flex items-center gap-2 border border-groq rounded-full p-4 my-4">
						<Info className="h-5 w-5" />
						{"We're currently undergoing maintenance. We'll be back soon!"}
					</div>
				)}
				<form
					className="flex flex-col relative border-2 border-border border-solid rounded-lg p-4 w-full max-w-2xl focus-within:border-groq dark:border-[#666666]"
					onSubmit={handleSubmit}
				>
					<textarea
						disabled={MAINTENANCE_GENERATION}
						value={query}
						onChange={(e) => setQuery(e.target.value)}
						className="w-full h-16 p-3 text-sm bg-transparent focus:outline-none resize-none"
						placeholder="Describe your app..."
					/>
						<div className="flex justify-between items-center w-full mt-4">
						<div className="flex items-center gap-2">
						<Button
							disabled={MAINTENANCE_GENERATION}
							type="button"
							variant="ghost"
							size="icon"
							className={`rounded-full shrink-0 flex items-center justify-center px-3 ${
								drawingData ? "min-w-[80px]" : "min-w-[40px]"
							}`}
							onClick={() => setShowDrawing(true)}
						>
							{drawingData ? (
								<div className="flex items-center gap-1.5">
									<Pencil className="h-4 w-4" />
									<span className="text-sm">Edit</span>
								</div>
							) : (
								<Pencil className="h-5 w-5" />
							)}
						</Button>
						<MicrophoneButton
							onTranscription={handleTranscription}
							disabled={MAINTENANCE_GENERATION}
						/>
						</div>
						<div className="flex items-center gap-2 ml-auto">
						<ModelSelector
						onChange={(model) => {
							setSelectedModel(model);
							setModel(model); // This will update both local and global states
						}}
						initialModel={model}
						/>
						<Button
							className="rounded-full"
							type="submit"
							disabled={MAINTENANCE_GENERATION}
						>
							Create
						</Button>
						</div>
					</div>
				</form>
			</div>
			{showDrawing && (
				<DrawingCanvas
					onDrawingComplete={handleDrawingComplete}
					onClose={() => setShowDrawing(false)}
				/>
			)}
			<div className="flex flex-wrap justify-center gap-3 items-center w-[90%] md:w-[60%] lg:w-[50%] pb-4 px-2">
				{APP_SUGGESTIONS.map((suggestion) => (
					<Button
						disabled={MAINTENANCE_GENERATION}
						key={suggestion}
						variant="outline"
						className="rounded-full text-xs whitespace-nowrap shrink-0"
						onClick={handleSuggestionClick(suggestion)}
					>
						{suggestion}
					</Button>
				))}
			</div>
			<div className="w-full px-4 mb-[100px]">
				<Link href="/gallery">
					<h2 className="font-montserrat text-2xl mt-20 mb-10 text-center">
						Gallery
					</h2>
				</Link>
				<div className="max-w-[1200px] mx-auto">
					<GalleryListing limit={10} view="trending" />
				</div>
				<div className="w-full flex justify-center mt-10">
					<Link
						href="/gallery"
						className="w-full text-sm text-muted-foreground text-center"
					>
						View all
					</Link>
				</div>
			</div>
		</div>
	);
}
```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/remove-button.tsx

```ts
"use client";

import { Button } from "@/components/ui/button";
import { Trash2 } from "lucide-react";
import { toast } from "react-hot-toast";
import { useState } from "react";
import { useRouter } from "next/navigation";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
	DialogTrigger,
} from "@/components/ui/dialog";

interface RemoveButtonProps {
	sessionId: string;
	version: string;
}

export function RemoveButton({ sessionId, version }: RemoveButtonProps) {
	const [isRemoving, setIsRemoving] = useState(false);
	const [isOpen, setIsOpen] = useState(false);
	const router = useRouter();

	const handleRemove = async () => {
		try {
			setIsRemoving(true);
			const response = await fetch(`/api/apps/${sessionId}/${version}/remove`, {
				method: "POST",
			});
			
			const data = await response.json();
			
			if (!response.ok) {
				throw new Error(data.error || "Failed to remove app");
			}

			toast.success("App removed successfully");
			// Navigate back to gallery after successful removal
			router.push("/gallery");
		} catch (error) {
			console.error("Error removing app:", error);
			toast.error(error instanceof Error ? error.message : "Failed to remove app");
		} finally {
			setIsRemoving(false);
			setIsOpen(false);
		}
	};

	return (
		<Dialog open={isOpen} onOpenChange={setIsOpen}>
			<DialogTrigger asChild>
				<Button
					variant="destructive"
					disabled={isRemoving}
					className="flex items-center gap-2"
				>
					<Trash2 size={16} />
					{isRemoving ? "Removing..." : "Remove"}
				</Button>
			</DialogTrigger>
			<DialogContent>
				<DialogHeader>
					<DialogTitle>Remove App</DialogTitle>
					<DialogDescription>
						Are you sure you want to remove this app? This action CANNOT be undone
						and the app will be permanently deleted.
					</DialogDescription>
				</DialogHeader>
				<DialogFooter>
					<Button variant="outline" onClick={() => setIsOpen(false)}>
						Cancel
					</Button>
					<Button variant="destructive" onClick={handleRemove} disabled={isRemoving}>
						{isRemoving ? "Removing..." : "Remove App"}
					</Button>
				</DialogFooter>
			</DialogContent>
		</Dialog>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/report-button.tsx

```ts
"use client";

import { Button } from "@/components/ui/button";
import { AlertCircle } from "lucide-react";
import { toast } from "react-hot-toast";
import { useState } from "react";

interface ReportButtonProps {
	sessionId: string;
	version: string;
}

export function ReportButton({ sessionId, version }: ReportButtonProps) {
	const [isReported, setIsReported] = useState(false);

	const reportApp = async () => {
		try {
			const response = await fetch("/api/report", {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					sessionId,
					appUrl: `${window.location.origin}/apps/${sessionId}/${version}`,
					rootUrl: window.location.origin,
					version,
				}),
			});

			if (!response.ok) {
				const error = await response.json();
				throw new Error(error.error || "Failed to report app");
			}

			setIsReported(true);
			toast.success("App reported successfully");
		} catch (error) {
			console.error("Error reporting app:", error);
			toast.error(error instanceof Error ? error.message : "Failed to report app");
		}
	};

	return (
		<Button
			variant="destructive"
			onClick={reportApp}
			disabled={isReported}
			className="flex items-center gap-2"
		>
			<AlertCircle size={16} />
			{isReported ? "Reported" : "Report"}
		</Button>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/studio-view.tsx

```ts
"use client";

import { Suspense, useEffect, useRef } from "react";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import {
	vscDarkPlus,
	vs,
} from "react-syntax-highlighter/dist/cjs/styles/prism";
import { CopyButton } from "@/components/CopyButton";
import { ReloadButton } from "@/components/ReloadButton";
import { ShareButton } from "@/components/share-button";
import { type HistoryEntry, useStudio } from "@/providers/studio-provider";
import { Button } from "@/components/ui/button";
import { X } from "lucide-react";
import { VersionSwitcher } from "./version-switcher";
import { NewButton } from "./new-button";
import { PromptInput } from "./prompt-input";
import { OptionsButton } from "./options-button";
import { useSearchParams } from "next/navigation";
import toast from "react-hot-toast";
import AppLogo from "@/components/AppLogo";
import { useTheme } from "next-themes";
import { cn } from "@/lib/utils";
import ModelSelector from "@/components/model-selector";
export default function StudioView() {
	return (
		<Suspense>
			<HomeContent />
		</Suspense>
	);
}
import { useState } from "react";

import { MODEL_OPTIONS } from "@/utils/models";

function HomeContent() {
	const searchParams = useSearchParams();
	const {
		history,
		historyIndex,
		navigateHistory,
		currentHtml,
		isOverlayOpen,
		setIsOverlayOpen,
		getFormattedOutput,
		iframeRef,
		setHistory,
		setHistoryIndex,
		setCurrentHtml,
		setMode,
		sessionId,
		setStudioMode,
		isApplying,
		isGenerating,
		isStreaming,
		streamingContent,
		streamingComplete,
		resetStreamingState,
		model,
		setModel,
	} = useStudio();
	const { resolvedTheme } = useTheme();
	const [selectedModel, setSelectedModel] = useState(MODEL_OPTIONS[0]); // Default model
	const sourceLoadedRef = useRef(false);
	
	useEffect(() => {
		const source = searchParams.get("source");
		if (source && !sourceLoadedRef.current) {
			sourceLoadedRef.current = true;
			const loadSourceVersion = async () => {
				resetStreamingState();
				
				try {
					const response = await fetch(`/api/apps/${source}`);
					if (!response.ok) {
						throw new Error("Failed to load source version");
					}

					let html = "";
					let signature = "";
					const content = await response.text();
					if (content.startsWith("{")) {
						const json = JSON.parse(content);
						html = json.html;
						signature = json.signature;
					} else {
						html = content;
						throw new Error("This pre-release version is not supported");
					}
					const newEntry: HistoryEntry = {
						html,
						feedback: "",
						sessionId,
						version: "1",
						signature,
					};
					setHistory([newEntry]);
					setHistoryIndex(0);
					setCurrentHtml(html);
					setMode("feedback");
					setStudioMode(true);
				} catch (error) {
					console.error("Error loading source version:", error);
					toast.error("Failed to load source version");
					sourceLoadedRef.current = false; // Reset if there was an error
				}
			};
			loadSourceVersion();
		}
	}, [
		searchParams,
		sessionId,
		setCurrentHtml,
		setHistory,
		setHistoryIndex,
		setMode,
		setStudioMode,
		resetStreamingState,
		isStreaming,
		streamingContent,
		streamingComplete,
	]);

	return (
		<main className="h-screen flex flex-col overflow-hidden">
			{/* Top Input Bar */}
			<div className="p-4 bg-background lg:border-b flex-shrink-0">
				<div className="flex flex-col gap-4">
					{/* Mobile Layout */}

					<div className="flex flex-col gap-4 lg:hidden">
						{/* Top Row - Controls */}
						<div className="flex items-center justify-between gap-2 mb-1">
							<NewButton />
							<VersionSwitcher
								className="justify-center flex-1"
								currentVersion={historyIndex + 1}
								totalVersions={history.length}
								onPrevious={() => navigateHistory("prev")}
								onNext={() => navigateHistory("next")}
							/>
							<OptionsButton />
						</div>
						{/* Bottom Row - Input and Model */}
						<div className="flex flex-col gap-2">
							<div className="w-full">
								<PromptInput />
							</div>
							<div className="w-full">
								<ModelSelector
									options={MODEL_OPTIONS}
									onChange={setModel}
									initialModel={model}
								/>
							</div>
						</div>
					</div>

					{/* Desktop Layout */}
					<div className="hidden lg:flex items-center gap-4">
						<NewButton />
						<VersionSwitcher
							currentVersion={historyIndex + 1}
							totalVersions={history.length}
							onPrevious={() => navigateHistory("prev")}
							onNext={() => navigateHistory("next")}
						/>
						<div className="flex-1">
							<PromptInput />
						</div>
						<ModelSelector
							options={MODEL_OPTIONS}
							onChange={setModel}
							initialModel={model}
						/>
						<OptionsButton />
					</div>
				</div>
			</div>

			{/* Main Content */}
			<div className="flex flex-1 overflow-hidden">
				{/* Left Column - Code View or Streaming Content */}
				<div className="w-1/2 p-4 border-r overflow-auto lg:block hidden">
					<div className="relative h-full">
						<div
							className={cn(
								"absolute top-0 left-0 h-[2px] bg-groq animate-loader",
								isGenerating || isApplying ? "opacity-100" : "opacity-0",
							)}
						/>
						
						{isStreaming ? (
							// Streaming content view - match SyntaxHighlighter background
							<div 
								className="h-full rounded font-mono text-sm overflow-auto p-4"
								style={{ 
									backgroundColor: resolvedTheme === "dark" ? "#1E1E1E" : "#f5f5f5",
									color: resolvedTheme === "dark" ? "#D4D4D4" : "#000000"
								}}
							>
								<div className="flex items-center mb-4">
									<div className="h-2 w-2 rounded-full bg-groq mr-2 animate-pulse"></div>
									<span className="text-xs text-muted-foreground">
										Generating your app...
									</span>
								</div>
								<div className="whitespace-pre-wrap">
									{streamingContent || "Thinking..."}
								</div>
							</div>
						) : (
							// Code view
							<SyntaxHighlighter
								language="html"
								style={resolvedTheme === "dark" ? vscDarkPlus : vs}
								className="h-full rounded"
								customStyle={{ margin: 0, height: "100%", width: "100%" }}
							>
								{currentHtml || "<!-- HTML preview will appear here -->"}
							</SyntaxHighlighter>
						)}
						
						<div className="absolute bottom-4 left-4">
							<CopyButton code={currentHtml} />
						</div>
					</div>
				</div>

				{/* Right Column - Preview */}
				<div className="lg:w-1/2 w-full overflow-hidden">
					<div className="h-full p-4 relative">
						{/* Mobile Code View - Only shown when streaming or generating */}
						{(isStreaming || isGenerating) && (
							<div 
								className="lg:hidden block mb-4 border rounded shadow-sm p-4"
								style={{ 
									backgroundColor: resolvedTheme === "dark" ? "#1E1E1E" : "#f5f5f5",
									color: resolvedTheme === "dark" ? "#D4D4D4" : "#000000"
								}}
							>
								<div className="flex items-center mb-2">
									<div className="h-2 w-2 rounded-full bg-groq mr-2 animate-pulse"></div>
									<span className="text-xs text-muted-foreground">
										{isStreaming ? "Generating your app..." : "Processing..."}
									</span>
								</div>
								{isStreaming && (
									<div className="whitespace-pre-wrap font-mono text-xs max-h-[200px] overflow-auto">
										{streamingContent || "Thinking..."}
									</div>
								)}
							</div>
						)}
						
						<div className="absolute top-6 right-6 flex gap-2 z-10">
							<ReloadButton iframeRef={iframeRef} />
							<ShareButton
								sessionId={history[historyIndex]?.sessionId}
								version={history[historyIndex]?.version}
								signature={history[historyIndex]?.signature}
								disabled={
									!history[historyIndex]?.sessionId ||
									!history[historyIndex]?.version
								}
							/>
						</div>
						<iframe
							title="Studio Preview"
							ref={iframeRef}
							srcDoc={`<style>body{background-color:${resolvedTheme === "dark" ? "rgb(30 30 30)" : "#ffffff"};margin:0;}</style>${currentHtml}`}
							className="w-full h-full border rounded bg-background shadow-sm"
							style={{ minHeight: "100%", minWidth: "100%", overflow: "auto" }}
						/>
					</div>
				</div>

				{/* Sliding Debug Overlay */}
				<div
					className={`fixed top-0 right-0 h-screen w-[60vw] bg-background shadow-lg transform transition-transform duration-300 overflow-hidden z-50 ${isOverlayOpen ? "translate-x-0" : "translate-x-full"}`}
				>
					<div className="h-full flex flex-col p-4">
						<div className="flex justify-between items-center mb-4 flex-shrink-0">
							<h2 className="font-medium">Prompt</h2>
							<Button
								variant="ghost"
								size="icon"
								onClick={() => setIsOverlayOpen(false)}
								className="text-gray-500 hover:text-gray-700"
							>
								<X size={16} />
							</Button>
						</div>
						<pre className="flex-1 text-sm bg-background p-4 rounded overflow-auto">
							{getFormattedOutput()}
						</pre>
					</div>
				</div>
			</div>
			<div className="flex flex-col md:flex-row w-full max-w-3xl mx-auto px-4 md:px-0">
				{/* Logo section */}
				<div className="md:w-1/2 md:pr-4 md:border-r flex items-center justify-center md:justify-end py-2">
					<span className="hidden md:inline text-sm text-muted-foreground">
						Powered by
					</span>
					<AppLogo className="scale-75" size={100} />
				</div>
				{/* Stats section */}
				<div className="md:w-1/2 md:pl-4 flex items-center justify-center md:justify-start py-2">
					<div className="text-sm text-muted-foreground text-center md:text-left">
						{history[historyIndex]?.usage && (
							<span>
								{(history[historyIndex].usage.total_time * 1000).toFixed(0)}ms ‚Ä¢{" "}
								{Math.round(
									history[historyIndex].usage.total_tokens /
										history[historyIndex].usage.total_time,
								)}{" "}
								tokens/sec ‚Ä¢{" "}
								<a
									rel="noreferrer"
									target="_blank"
									className="underline"
									href="https://console.groq.com/docs/models"
								>
									Build with Groq!
								</a>
							</span>
						)}
					</div>
				</div>
			</div>
		</main>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/submit-button.tsx

```ts
import { Button } from "@/components/ui/button";
import { useStudio } from "@/providers/studio-provider";
import { SendHorizontal, Wand2 } from "lucide-react";

export function SubmitButton() {
	const {
		mode,
		query,
		isGenerating,
		isApplying,
		generateHtml,
		submitFeedback,
	} = useStudio();
	return (
		<Button
			disabled={
				(mode === "query" && (!query.trim() || isGenerating)) ||
				(mode === "feedback" && isApplying)
			}
			size="default"
			className={`bg-groq text-groq-foreground transition-all duration-200 rounded-full lg:px-4 lg:h-10 lg:w-auto w-10 h-10 ${
				isGenerating || isApplying
					? "loading-animation"
					: "bg-[#F55036] hover:bg-[#D93D26]"
			}`}
			onClick={mode === "query" ? generateHtml : submitFeedback}
		>
			<span className="hidden lg:inline">
				{mode === "query"
					? isGenerating
						? "Generating..."
						: "Generate"
					: isApplying
						? "Applying..."
						: "Apply Edit"}
			</span>
			<span className="lg:hidden">
				{mode === "query" ? (
					<Wand2 className="h-4 w-4" />
				) : (
					<SendHorizontal className="h-4 w-4" />
				)}
			</span>
		</Button>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/upvote-button.tsx

```ts
import { ThumbsUp } from "lucide-react";
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "react-hot-toast";

export function UpvoteButton({
  sessionId,
  version,
  initialUpvotes = -1,
}: {
  sessionId: string;
  version: string;
  initialUpvotes?: number;
}) {
  const [upvotes, setUpvotes] = useState(initialUpvotes);
  const [isLoading, setIsLoading] = useState(false);
  const [hasVoted, setHasVoted] = useState(false);

  useEffect(() => {
    const fetchUpvotes = async () => {
      try {
        const response = await fetch(`/api/apps/${sessionId}/${version}/upvote`, {
          method: "GET",
        });
        
        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || "Failed to fetch upvotes");
        }
        
        const data = await response.json();
        setUpvotes(data.upvotes);
      } catch (error) {
        console.error("Failed to fetch upvotes:", error);
      }
    };

    fetchUpvotes();
  }, [sessionId, version]);

  const handleUpvote = async () => {
    if (hasVoted) {
      toast.error("You've already voted for this app!");
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch(`/api/apps/${sessionId}/${version}/upvote`, {
        method: "POST",
      });
      
      if (!response.ok) {
        const data = await response.json();
        if (data.error === "Already voted") {
          setHasVoted(true);
          throw new Error("You've already voted for this app!");
        }
        throw new Error(data.error || "Failed to upvote");
      }
      
      const data = await response.json();
      setUpvotes(data.upvotes);
      setHasVoted(true);
      toast.success("Thanks for your vote!", {
        duration: 3000,
      });
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Could not upvote. Please try again later", {
        duration: 3000,
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button
      variant="outline"
      className="flex gap-2 px-3"
      onClick={handleUpvote}
      disabled={isLoading || hasVoted}
    >
      {upvotes === -1 ? (
        <span className="animate-pulse">Loading...</span>
      ) : (
        <>
          <ThumbsUp className={hasVoted ? "text-blue-500" : ""} /> {upvotes}
        </>
      )}
    </Button>
  );
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/components/version-switcher.tsx

```ts
import { IoChevronBackOutline, IoChevronForwardOutline } from "react-icons/io5";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { Button } from "@/components/ui/button";
interface VersionSwitcherProps {
	currentVersion: number;
	totalVersions: number;
	onPrevious: () => void;
	onNext: () => void;
	className?: string;
}

export function VersionSwitcher({
	currentVersion,
	totalVersions,
	onPrevious,
	onNext,
	className = "",
}: VersionSwitcherProps) {
	return (
		<div className={`flex items-center gap-2 ${className}`}>
			<Button
				variant="ghost"
				size="icon"
				onClick={onPrevious}
				disabled={currentVersion <= 1}
				aria-label="Previous version"
			>
				<ChevronLeft size={20} />
			</Button>
			<span className="text-sm dark:text-gray-400 text-gray-600 min-w-[80px] text-center">
				Version {currentVersion} of {totalVersions}
			</span>
			<Button
				variant="ghost"
				size="icon"
				onClick={onNext}
				disabled={currentVersion >= totalVersions}
				aria-label="Next version"
			>
				<ChevronRight size={20} />
			</Button>
		</div>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/gallery/page.tsx

```ts
"use client";

import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { GalleryListing } from "../components/gallery-listing";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useState } from "react";

export default function GalleryPage() {
	const [view, setView] = useState<"trending" | "popular" | "new">("popular");

	return (
		<main className="p-4">
			<div className="flex items-center gap-2 mb-6">
				<Link href="/" className="w-10 h-10 flex items-center justify-center">
					<ArrowLeft size={20} />
				</Link>
				<h1 className="font-montserrat text-[2em] font-light">Gallery</h1>
			</div>

			<div className="mb-8 flex justify-center">
				<Tabs value={view} onValueChange={(v) => setView(v as typeof view)} className="w-full max-w-md">
					<TabsList className="grid w-full grid-cols-3">
						<TabsTrigger value="trending">Trending</TabsTrigger>
						<TabsTrigger value="popular">Popular</TabsTrigger>
						<TabsTrigger value="new">New</TabsTrigger>
					</TabsList>
				</Tabs>
			</div>

			<GalleryListing view={view} />
		</main>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/apps/[sessionId]/[version]/layout.tsx

```ts
import { getFromStorageWithRegex, getStorageKey } from "@/server/storage";
import type { Metadata } from "next";
import { ROOT_URL } from "@/utils/config";
import { headers } from "next/headers";

interface LayoutProps {
	children: React.ReactNode;
	params: {
		sessionId: string;
		version: string;
	};
}

export async function generateMetadata({
	params,
}: LayoutProps): Promise<Metadata> {
	const { sessionId, version } = params;

	try {
		const headersList = headers();
		const key = getStorageKey(sessionId, version);
		const { value:res } = await getFromStorageWithRegex(key);
		
		if (!res) {
			return {};
		}

		const data = JSON.parse(res);
		if (data) {
			return {
				title: data.title,
				description: data.description,
				openGraph: {
					title: data.title,
					description: data.description,
					images: `https://image.thum.io/get/${ROOT_URL}/api/apps/${sessionId}/${version}/raw`,
					type: "website",
				},
			};
		}
	} catch (error) {
		console.error("Error generating metadata:", error);
	}

	return {};
}

export default function Layout({ children, params }: LayoutProps) {
	return <>{children}</>;
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/apps/[sessionId]/[version]/page.tsx

```ts
"use client";

import { useEffect, useState } from "react";
import { RemixButton } from "@/components/RemixButton";
import { Button } from "@/components/ui/button";
import { ReportButton } from "@/app/components/report-button";
import { UpvoteButton } from "@/app/components/upvote-button";
import { RemoveButton } from "@/app/components/remove-button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";

interface AppData {
	html: string;
	avoidGallery?: boolean;
}

export default function SharedApp({
	params,
}: {
	params: { sessionId: string; version: string };
}) {
	const [html, setHtml] = useState("");
	const [showWarning, setShowWarning] = useState(true);
	const [isInGallery, setIsInGallery] = useState<boolean>(true);

	useEffect(() => {
		const fetchHtml = async () => {
			try {
				const response = await fetch(
					`/api/apps/${params.sessionId}/${params.version}`,
				);
				if (!response.ok) {
					throw new Error("Failed to fetch HTML");
				}
				const content = await response.text();
				if (content.startsWith("{")) {
					const data: AppData = JSON.parse(content);
					setHtml(data.html);
					setIsInGallery(!data.avoidGallery);
				} else {
					setHtml(content);
				}
			} catch (error) {
				console.error("Error fetching HTML:", error);
			}
		};

		if (!showWarning) {
			fetchHtml();
		}
	}, [params.sessionId, params.version, showWarning]);

	return (
		<div className="w-screen h-screen relative">
			<Dialog open={showWarning} onOpenChange={setShowWarning}>
				<DialogContent>
					<DialogHeader>
						<DialogTitle>Warning</DialogTitle>
						<DialogDescription>
							This is user generated content. Groq is not responsible for the content.
						</DialogDescription>
					</DialogHeader>
					<DialogFooter>
						<Button onClick={() => setShowWarning(false)}>
							Continue
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>
			{!showWarning && (
				<>
					<iframe
						title="Shared App"
						srcDoc={html}
						className="w-full h-full border-0"
						style={{ height: "100vh" }}
					/>
					<div className="absolute bottom-4 right-4 flex gap-2 z-10">
						<ReportButton
							sessionId={params.sessionId}
							version={params.version}
						/>
						<RemoveButton
							sessionId={params.sessionId}
							version={params.version}
						/>
						<RemixButton
							sessionId={params.sessionId}
							version={params.version}
						/>
						{isInGallery && (
							<UpvoteButton
								sessionId={params.sessionId}
								version={params.version}
							/>
						)}
					</div>
				</>
			)}
		</div>
	);
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/apps/route.ts

```ts
// File: app/appgen/src/app/api/apps/route.ts

import { NextRequest, NextResponse } from "next/server";
import path from "path";
import { promises as fs } from "fs";

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
	try {
		// Define the directory where projects are stored.
		const projectsDir = path.join(process.cwd(), "..");

		// Read all entries in the projects folder.
		const entries = await fs.readdir(projectsDir);

		// Get metadata for each entry.
		const projects = await Promise.all(
			entries.map(async (entry) => {
				const fullPath = path.join(projectsDir, entry);
				const stat = await fs.stat(fullPath);
				return {
					name: entry,
					isDirectory: stat.isDirectory(),
					size: stat.size,
					createdAt: stat.birthtime, // or stat.ctime if preferred
				};
			})
		);

		// Filter to include only directories (assuming each project is a folder).
		let filteredProjects = projects.filter((p) => p.isDirectory);

		// Read the 'view' query parameter (e.g. trending).
		const view = request.nextUrl.searchParams.get("view") || "all";

		// If view is trending, filter projects created within the last 24 hours and sort descending by creation date.
		if (view === "trending") {
			const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
			filteredProjects = filteredProjects.filter(
				(project) => new Date(project.createdAt) >= twentyFourHoursAgo
			);
			filteredProjects.sort(
				(a, b) =>
					new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
			);
		}

		return NextResponse.json(filteredProjects);
	} catch (error) {
		console.error("Error reading projects:", error);
		return NextResponse.json(
			{ error: "Failed to read projects" },
			{ status: 500 }
		);
	}
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/block/route.ts

```ts
import { NextRequest, NextResponse } from "next/server";
import { blockIP } from "@/server/storage";

export async function GET(request: NextRequest) {
    const searchParams = new URL(request.url).searchParams;
    const ip = searchParams.get("ip");
    const token = searchParams.get("token");

    if (!ip || !token) {
        return new NextResponse("Missing ip or token parameter", { status: 400 });
    }

    try {
        await blockIP(ip, token);
        
        return new NextResponse(JSON.stringify({ success: true }), {
            headers: {
                "Content-Type": "application/json",
            },
        });
    } catch (error) {
        if (error instanceof Error && error.message === "Invalid token") {
            return new NextResponse("Unauthorized", { status: 401 });
        }
        console.error("Error blocking IP:", error);
        return new NextResponse("Internal Server Error", { status: 500 });
    }
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/generate/route.ts

```ts
// C:\Users\katle\Desktop\theFlex\lastLast\app\appgen\src\app\api\generate\route.ts
import { NextResponse } from "next/server";
import { Ollama } from "ollama";
import { constructPrompt } from "@/utils/prompt";
import {
	PRIMARY_MODEL,
	VANILLA_MODEL,
	PRIMARY_VISION_MODEL,
	FALLBACK_VISION_MODEL,
	getFallbackModel,
	getModelTemperature,
	getModelMaxTokens
} from "@/utils/models";
import {
	MAINTENANCE_GENERATION,
	MAINTENANCE_USE_VANILLA_MODEL,
} from "@/lib/settings";

const ollama = new Ollama();

async function tryCompletion(prompt: string, model: string, stream = false) {
	console.log("Ollama Completion: Calling client.chat with prompt:", prompt);
	console.log("Using model:", model, "stream:", stream);
	const completion = await ollama.chat({
		messages: [{ role: "user", content: prompt }],
		model: model,
		stream,
	});
	console.log("Ollama Completion: Received completion response:", completion);
	return completion;
}

async function generateWithFallback(prompt: string, model: string, stream = false) {
	try {
		console.log("Ollama Generate: Attempting primary call.");
		const chatCompletion = await tryCompletion(
			prompt,
			MAINTENANCE_USE_VANILLA_MODEL ? VANILLA_MODEL : model,
			stream
		);
		console.log("Ollama Generate: Primary call succeeded.");
		return chatCompletion;
	} catch (error) {
		console.error("Ollama Generate: Primary call failed. Error:", error);
		console.log("Ollama Generate: Attempting fallback call with model:", getFallbackModel());
		const fallbackCompletion = await tryCompletion(prompt, getFallbackModel(), stream);
		console.log("Ollama Generate: Fallback call succeeded. Response:", fallbackCompletion);
		return fallbackCompletion;
	}
}

async function getDrawingDescription(imageData: string): Promise<string> {
	try {
		console.log("Ollama Vision: Calling client.chat to describe drawing. Image data:", imageData);
		const chatCompletion = await ollama.chat({
			messages: [
				{
					role: "user",
					content: [
						{
							type: "text",
							text: "Describe this UI drawing in detail",
						},
						{
							type: "image_url",
							image_url: { url: imageData },
						},
					],
				},
			],
			model: PRIMARY_VISION_MODEL,
			stream: false
		});
		console.log("Ollama Vision: Received drawing description:", chatCompletion.message.content);
		return chatCompletion.message.content;
	} catch (error) {
		console.error("Ollama Vision: Primary vision call failed. Error:", error);
		console.log("Ollama Vision: Attempting fallback vision call.");
		const chatCompletion = await ollama.chat({
			messages: [
				{
					role: "user",
					content: [
						{
							type: "text",
							text: "Describe this UI drawing in detail",
						},
						{
							type: "image_url",
							image_url: { url: imageData },
						},
					],
				},
			],
			model: FALLBACK_VISION_MODEL,
			stream: false
		});
		console.log("Ollama Vision: Fallback vision call succeeded. Response:", chatCompletion.message.content);
		return chatCompletion.message.content;
	}
}

export async function POST(request: Request) {
	if (MAINTENANCE_GENERATION) {
		return NextResponse.json(
			{ error: "We're currently undergoing maintenance. We'll be back soon!" },
			{ status: 500 }
		);
	}

	try {
		const { query, currentHtml, feedback, theme, drawingData, model, stream = false } =
			await request.json();
		let finalQuery = query;
		if (drawingData) {
			const drawingDescription = await getDrawingDescription(drawingData);
			finalQuery = `${query}\n\nDrawing description: ${drawingDescription}`;
		}

		const prompt = constructPrompt({
			...(finalQuery && { query: finalQuery }),
			currentHtml,
			currentFeedback: feedback,
			theme,
		});
		console.log("Ollama Generate Route: Constructed prompt:", prompt);

		// SAFETY CHECK REMOVED

		if (stream) {
			const encoder = new TextEncoder();
			console.log("Ollama Generate Route: Starting streaming generation.");
			const streamingCompletion = await generateWithFallback(prompt, model, true);

			const responseStream = new ReadableStream({
				async start(controller) {
					controller.enqueue(encoder.encode(JSON.stringify({ type: "start" }) + "\n"));
					try {
						let fullContent = "";
						for await (const chunk of streamingCompletion as any) {
							const content = chunk.delta?.content || "";
							if (content) {
								fullContent += content;
								console.log("Ollama Generate Route: Streaming chunk:", content);
								controller.enqueue(
									encoder.encode(
										JSON.stringify({ type: "chunk", content }) + "\n"
									)
								);
							}
						}
						let generatedHtml = fullContent;
						if (generatedHtml.includes("```html")) {
							const match = generatedHtml.match(/```html\n([\s\S]*?)\n```/);
							generatedHtml = match ? match[1] : generatedHtml;
						}
						console.log("Ollama Generate Route: Streaming complete. Final HTML:", generatedHtml);
						controller.enqueue(
							encoder.encode(
								JSON.stringify({
									type: "complete",
									html: generatedHtml,
									signature: generatedHtml,
								}) + "\n"
							)
						);
						controller.close();
					} catch (error) {
						console.error("Ollama Generate Route: Error in streaming:", error);
						controller.enqueue(
							encoder.encode(
								JSON.stringify({ type: "error", error: "Error generating content" }) + "\n"
							)
						);
						controller.close();
					}
				},
			});

			return new Response(responseStream, {
				headers: {
					"Content-Type": "text/event-stream",
					"Cache-Control": "no-cache",
					"Connection": "keep-alive",
				},
			});
		} else {
			console.log("Ollama Generate Route: Starting non-streaming generation.");
			const chatCompletion = await generateWithFallback(prompt, model, false) as any;
			let generatedHtml = chatCompletion.message?.content || "";
			if (generatedHtml.includes("```html")) {
				const match = generatedHtml.match(/```html\n([\s\S]*?)\n```/);
				generatedHtml = match ? match[1] : generatedHtml;
			}
			console.log("Ollama Generate Route: Non-streaming completion. Final HTML:", generatedHtml);
			return NextResponse.json({
				html: generatedHtml,
				signature: generatedHtml,
				usage: chatCompletion.usage,
			});
		}
	} catch (error) {
		console.error("Ollama Generate Route: Error generating HTML:", error);
		return NextResponse.json({ error: "Failed to generate HTML" }, { status: 500 });
	}
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/report/route.ts

```ts
import { NextRequest, NextResponse } from "next/server";
import { getFromStorageWithRegex, getStorageKey } from "@/server/storage";
import { ROOT_URL } from "@/utils/config";

export async function POST(request: NextRequest) {
    const { sessionId, version, rootUrl = ROOT_URL, appUrl } = await request.json();
    try {
        // Get the app data to find the creator's IP
        const key = getStorageKey(sessionId, version);
        const { value: appDataStr } = await getFromStorageWithRegex(key);
        
        if (!appDataStr) {
            return NextResponse.json(
                { error: "App not found" },
                { status: 404 }
            );
        }

        const appData = JSON.parse(appDataStr);
        const creatorIP = appData.creatorIP;

        if (!creatorIP) {
            return NextResponse.json(
                { error: "Creator IP not found" },
                { status: 404 }
            );
        }

        // Generate the ban URL
        const banUrl = `${rootUrl}/block?ip=${encodeURIComponent(creatorIP)}&token=${encodeURIComponent(process.env.BLOCK_SECRET || "")}`;

        // Send to Slack
        const slackWebhookUrl = process.env.SLACK_WEBHOOK;
        if (slackWebhookUrl) {

            await fetch(slackWebhookUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  ban_url: banUrl,
                  app_url: appUrl
                }),
            });
        }

        return NextResponse.json({ success: true, banUrl });
    } catch (error) {
        console.error("Error processing report:", error);
        return NextResponse.json(
            { error: "Failed to process report" },
            { status: 500 }
        );
    }
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/suggest/route.ts

```ts
// C:\Users\katle\Desktop\theFlex\lastLast\app\appgen\src\app\api\suggest\route.ts
import { NextResponse } from 'next/server';
import { Ollama } from "ollama";
import { PRIMARY_MODEL, getFallbackModel, getModelTemperature } from '@/utils/models';

const client = new Ollama();

async function generateSuggestionWithFallback(messages: any[]) {
  try {
    console.log("Ollama Suggest: Calling client.chat with messages:", messages);
    const response = await client.chat({
      messages,
      model: PRIMARY_MODEL,
      temperature: getModelTemperature(PRIMARY_MODEL),
      max_tokens: 200,
      top_p: 1,
    });
    console.log("Ollama Suggest: Primary response:", response);
    return response;
  } catch (error) {
    console.error("Ollama Suggest: Primary model failed, trying fallback model. Error:", error);
    const fallbackResponse = await client.chat({
      messages,
      model: getFallbackModel(),
      temperature: getModelTemperature(getFallbackModel()),
      max_tokens: 2048,
      top_p: 1,
    });
    console.log("Ollama Suggest: Fallback response:", fallbackResponse);
    return fallbackResponse;
  }
}

export async function POST(request: Request) {
  try {
    const { html } = await request.json();

    if (!html) {
      return NextResponse.json(
        { error: 'HTML content is required' },
        { status: 400 }
      );
    }

    console.log("Ollama Suggest: Generating suggestion for HTML content:", html);
    const completion = await generateSuggestionWithFallback([
      {
        role: 'user',
        content: `Given this HTML content, suggest a concise title and brief description that captures the essence of the app. The title should be descriptive, while the description should explain what the app does in a single sentence. Format the response as JSON with "title" and "description" fields.

<app html>
${html}
</app html>`
      },
    ]);
    console.log("Ollama Suggest: Full response:", completion);

    const responseContent = completion.choices[0]?.message?.content || '';
    const startIndex = responseContent.indexOf('{');
    const endIndex = responseContent.lastIndexOf('}');

    if (startIndex === -1 || endIndex === -1) {
      throw new Error('Invalid JSON response from AI');
    }

    const jsonContent = responseContent.substring(startIndex, endIndex + 1);
    const suggestions = JSON.parse(jsonContent);
    console.log("Ollama Suggest: Parsed suggestions:", suggestions);

    return NextResponse.json(suggestions);
  } catch (error) {
    console.error('Ollama Suggest: Error generating suggestions:', error);
    return NextResponse.json(
      { error: 'Failed to generate suggestions' },
      { status: 500 }
    );
  }
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/transcribe/route.ts

```ts
import { NextResponse } from 'next/server';
import Groq from 'groq-sdk';

const client = new Groq({
  apiKey: process.env.GROQ_API_KEY,
});

async function transcribeAudio(audioBlob: Blob): Promise<Groq.Audio.Transcriptions.Transcription> {
  try {
    const arrayBuffer = await audioBlob.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const file = new File([buffer], 'audio.webm', { type: 'audio/webm' });
    
    const transcription = await client.audio.transcriptions.create({
      file,
      model: 'whisper-large-v3-turbo',
      response_format: 'text',
      language: 'en'
    });

    return transcription;
  } catch (error) {
    console.error('Error transcribing audio:', error);
    throw error;
  }
}

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const audioFile = formData.get('audio');

    if (!audioFile || !(audioFile instanceof Blob)) {
      return NextResponse.json(
        { error: 'No audio file provided' },
        { status: 400 }
      );
    }

    const transcription = await transcribeAudio(audioFile);

    return NextResponse.json({
      transcription
    });

  } catch (error) {
    console.error('Error processing audio:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to process audio file' },
      { status: 500 }
    );
  }
}
```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/apps/[sessionId]/[version]/route.ts

```ts
import { NextRequest, NextResponse } from "next/server";
import { getFromStorageWithRegex, saveToStorage, getStorageKey, addToGallery, isIPBlocked } from "@/server/storage";

export async function GET(
	request: NextRequest,
	{ params }: { params: { sessionId: string; version: string } },
) {
	const { sessionId, version } = params;
	const raw = request.nextUrl.searchParams.get("raw") === "true";

	try {
		const key = getStorageKey(sessionId, version);
		const { value } = await getFromStorageWithRegex(key);

		if (!value) {
			return NextResponse.json({ error: "Not found" }, { status: 404 });
		}

		const data = JSON.parse(value);
		if (raw) {
			return new NextResponse(data.html, {
				headers: {
					"Content-Type": "text/html",
				},
			});
		}
		return NextResponse.json(data);
	} catch (error) {
		console.error("Error retrieving app:", error);
		return NextResponse.json(
			{ error: "Failed to retrieve app" },
			{ status: 500 }
		);
	}
}

export async function POST(
	request: NextRequest,
	{ params }: { params: { sessionId: string; version: string } },
) {
	const { sessionId, version } = params;

	try {
		const { html, signature, avoidGallery, ...rest } = await request.json();
		const ip = request.headers.get("x-forwarded-for") || request.ip || "unknown";

		if (await isIPBlocked(ip)) {
			console.warn(`Someone tried to submit from a blocked IP: ${ip}`);
			return NextResponse.json(
				{ error: "IP address is blocked" },
				{ status: 403 }
			);
		}

		const key = getStorageKey(sessionId, version, ip);


		// Add creatorIP to the stored data
		const data = {
			html,
			signature,
			...rest,
			avoidGallery,
			creatorIP: ip,
			createdAt: new Date().toISOString(),
		};

		await saveToStorage(key, JSON.stringify(data));

		if (!avoidGallery) {
			let success = await addToGallery({ 
				sessionId, 
				version, 
				signature,
				...rest,
			}, ip);
			if(!success) {
				return NextResponse.json(
					{ error: "Failed to save app" },
					{ status: 500 }
				);
			}
		}

		return NextResponse.json({ success: true });
	} catch (error) {
		console.error("Error saving app:", error);
		return NextResponse.json(
			{ error: "Failed to save app" },
			{ status: 500 }
		);
	}
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/apps/[sessionId]/[version]/raw/route.ts

```ts
import { NextRequest, NextResponse } from "next/server";
import { getFromStorageWithRegex, getStorageKey } from "@/server/storage";

export async function GET(
	request: NextRequest,
	{ params }: { params: { sessionId: string; version: string } }
) {
	const { sessionId, version } = params;

	try {
		const key = getStorageKey(sessionId, version);
		const {value} = await getFromStorageWithRegex(key);

		if (!value) {
			return NextResponse.json({ error: "Not found" }, { status: 404 });
		}

		const data = JSON.parse(value);
		return new NextResponse(data.html, {
			headers: {
				"Content-Type": "text/html",
			},
		});
	} catch (error) {
		console.error("Error retrieving raw app:", error);
		return NextResponse.json(
			{ error: "Failed to retrieve app" },
			{ status: 500 }
		);
	}
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/apps/[sessionId]/[version]/remove/route.ts

```ts
import { NextRequest, NextResponse } from "next/server";
import { removeGalleryItem } from "@/server/storage";

export async function POST(
    request: NextRequest,
    { params }: { params: { sessionId: string; version: string } }
) {
    const { sessionId, version } = params;
    const ip = request.headers.get("x-forwarded-for") || request.ip || "unknown";

    try {
        const removed = await removeGalleryItem(sessionId, version, ip);
        if (removed) {
            return NextResponse.json({ success: true });
        } else {
            return NextResponse.json(
                { error: "Item not found" },
                { status: 404 }
            );
        }
    } catch (error) {
        if (error instanceof Error) {
            if (error.message.includes("Unauthorized")) {
                return NextResponse.json(
                    { error: "You can only remove your own submissions" },
                    { status: 401 }
                );
            }
            return NextResponse.json(
                { error: error.message },
                { status: 500 }
            );
        }
        return NextResponse.json(
            { error: "Failed to remove item" },
            { status: 500 }
        );
    }
}

```

### C:/Users/katle/Desktop/theFlex/lastLast/app/appgen/src/app/api/apps/[sessionId]/[version]/upvote/route.ts

```ts
import { NextRequest, NextResponse } from "next/server";
import { upvoteGalleryItem, getUpvotes } from "@/server/storage";

export async function POST(
  request: NextRequest,
  { params }: { params: { sessionId: string; version: string } }
) {
  try {
    const clientIp = request.headers.get("x-forwarded-for") || request.ip || "unknown";
    const timestamp = new Date().toISOString();
    const upvoteCount = await upvoteGalleryItem(params.sessionId, params.version, clientIp, timestamp);
    return NextResponse.json({ upvotes: upvoteCount });
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to upvote" },
      { status: 400 }
    );
  }
}

export async function GET(
  _request: NextRequest,
  { params }: { params: { sessionId: string; version: string } }
) {
  try {
    const upvoteCount = await getUpvotes(params.sessionId, params.version);
    return NextResponse.json({ upvotes: upvoteCount });
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to get upvotes" },
      { status: 400 }
    );
  }
}
```



## question
why might the generated html not be being sent to the Studio Preview?
- modify code so that it will retry max 3 times if no html tag found


### Tips to keep user happy:
- Implement improvements where fit
- Stick to DRY principles
- Provide full pieces of code based on the files that need to be changed

